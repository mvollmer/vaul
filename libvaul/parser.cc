
/*  A Bison parser, made from parser.yy with Bison version GNU Bison version 1.22
  */

#define YYBISON 1  /* Identify Bison output.  */

#define YYLSP_NEEDED

#define	t_ACCESS	258
#define	t_AFTER	259
#define	t_ALIAS	260
#define	t_ALL	261
#define	t_AND	262
#define	t_ARCHITECTURE	263
#define	t_ARRAY	264
#define	t_ASSERT	265
#define	t_ATTRIBUTE	266
#define	t_BEGIN	267
#define	t_BLOCK	268
#define	t_BODY	269
#define	t_BUFFER	270
#define	t_BUS	271
#define	t_CASE	272
#define	t_COMPONENT	273
#define	t_CONFIGURATION	274
#define	t_CONSTANT	275
#define	t_DISCONNECT	276
#define	t_DOWNTO	277
#define	t_ELSE	278
#define	t_ELSIF	279
#define	t_END	280
#define	t_ENTITY	281
#define	t_EXIT	282
#define	t_FILE	283
#define	t_FOR	284
#define	t_FUNCTION	285
#define	t_GENERATE	286
#define	t_GENERIC	287
#define	t_GUARDED	288
#define	t_IF	289
#define	t_IN	290
#define	t_INOUT	291
#define	t_IS	292
#define	t_LABEL	293
#define	t_LIBRARY	294
#define	t_LINKAGE	295
#define	t_LOOP	296
#define	t_MAP	297
#define	t_NAND	298
#define	t_NEW	299
#define	t_NEXT	300
#define	t_NOR	301
#define	t_NULL	302
#define	t_OF	303
#define	t_ON	304
#define	t_OPEN	305
#define	t_OR	306
#define	t_OTHERS	307
#define	t_OUT	308
#define	t_PACKAGE	309
#define	t_PORT	310
#define	t_PROCEDURE	311
#define	t_PROCESS	312
#define	t_RANGE	313
#define	t_RECORD	314
#define	t_REGISTER	315
#define	t_REPORT	316
#define	t_RETURN	317
#define	t_SELECT	318
#define	t_SEVERITY	319
#define	t_SIGNAL	320
#define	t_SUBTYPE	321
#define	t_THEN	322
#define	t_TO	323
#define	t_TRANSPORT	324
#define	t_TYPE	325
#define	t_UNITS	326
#define	t_UNTIL	327
#define	t_USE	328
#define	t_VARIABLE	329
#define	t_WAIT	330
#define	t_WHEN	331
#define	t_WHILE	332
#define	t_WITH	333
#define	t_XOR	334
#define	t_EQSym	335
#define	t_NESym	336
#define	t_LTSym	337
#define	t_LESym	338
#define	t_GTSym	339
#define	t_GESym	340
#define	t_Plus	341
#define	t_Minus	342
#define	t_Ampersand	343
#define	MED_PRECEDENCE	344
#define	t_Star	345
#define	t_Slash	346
#define	t_MOD	347
#define	t_REM	348
#define	t_DoubleStar	349
#define	t_ABS	350
#define	t_NOT	351
#define	MAX_PRECEDENCE	352
#define	t_Apostrophe	353
#define	t_LeftParen	354
#define	t_RightParen	355
#define	t_Comma	356
#define	t_VarAsgn	357
#define	t_Colon	358
#define	t_Semicolon	359
#define	t_Arrow	360
#define	t_Box	361
#define	t_Bar	362
#define	t_Dot	363
#define	t_AbstractLit	364
#define	t_CharacterLit	365
#define	t_StringLit	366
#define	t_Identifier	367

#line 62 "parser.yy"


#include <vaul/tree.h>
#include <vaul/lexer.h>
#include <vaul/parser.h>
#include <vaul/design_unit.h>
#include <vaul/library.h>
#include <vaul/list.h>

#include <stdio.h>
#include <stdarg.h>
#include <vaulutil.h>
#include <assert.h>

#define yylex(sem, loc) lex->lex(sem, loc)
#define yyparse		vaul_parser::bison_parse
#define yyerror		BisonError

#define YYSTYPE vaul_yystype
#define YYLTYPE vaul_yyltype

#if 1
// Erweiterte Fehlermeldungen waeren ja ganz schön, aber die
// Namen fuer die Token sind nicht sehr elegant.
#define YYDEBUG 1
#define YYERROR_VERBOSE
#endif

#define NEW_NODE_PLACEMENT (pool)
#include "tree.m"

// XXX - tidy up, used only for RANGE attribute resolution

static void iterate_for_kind(nDeclaration d, void *cl)
{
    nKind &basic_k = *(nKind *)cl;
    nKind this_k = d->kind();

    if(basic_k == nkInvalid)
	basic_k = this_k;
    else if(basic_k != this_k && !sNode::is_base_of(basic_k, this_k)) {
	while(!sNode::is_base_of(this_k, basic_k))
	    this_k = sNode::base_kind(this_k);
	basic_k = this_k;
    }
}


#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		873
#define	YYFLAG		-32768
#define	YYNTBASE	113

#define YYTRANSLATE(x) ((unsigned)(x) <= 367 ? yytranslate[x] : 370)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,
    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,
    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,
   106,   107,   108,   109,   110,   111,   112
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     3,     5,     7,     9,    11,    13,    15,    17,
    19,    21,    24,    25,    27,    30,    32,    36,    39,    40,
    43,    45,    47,    49,    51,    53,    55,    57,    61,    65,
    67,    71,    72,    84,    85,    87,    91,    92,    94,    98,
    99,   102,   103,   106,   109,   111,   112,   114,   115,   128,
   129,   132,   135,   137,   138,   150,   151,   154,   157,   159,
   160,   169,   170,   173,   176,   178,   179,   189,   190,   193,
   197,   199,   201,   203,   205,   207,   209,   211,   213,   215,
   217,   219,   221,   223,   225,   227,   229,   231,   233,   235,
   237,   239,   241,   243,   245,   247,   249,   251,   253,   255,
   257,   259,   261,   263,   265,   267,   269,   271,   273,   275,
   277,   279,   281,   284,   286,   290,   296,   297,   299,   300,
   310,   311,   313,   314,   317,   319,   321,   326,   327,   331,
   339,   340,   342,   343,   345,   346,   348,   350,   352,   354,
   356,   358,   363,   365,   366,   370,   375,   376,   380,   384,
   386,   388,   390,   392,   394,   396,   398,   400,   402,   404,
   406,   408,   410,   414,   418,   420,   424,   428,   432,   436,
   440,   444,   446,   449,   452,   455,   458,   462,   466,   470,
   474,   478,   482,   486,   490,   494,   498,   502,   506,   510,
   514,   516,   518,   520,   522,   524,   528,   530,   532,   534,
   536,   538,   540,   544,   548,   550,   552,   554,   556,   559,
   562,   566,   570,   574,   578,   581,   582,   586,   589,   595,
   600,   604,   610,   614,   619,   623,   626,   627,   629,   633,
   635,   638,   639,   643,   645,   647,   649,   651,   656,   657,
   660,   662,   664,   666,   668,   670,   672,   674,   676,   680,
   683,   684,   687,   694,   695,   698,   701,   706,   713,   716,
   717,   721,   725,   730,   736,   737,   740,   745,   748,   752,
   758,   761,   763,   767,   770,   774,   775,   777,   780,   785,
   786,   790,   792,   794,   796,   800,   802,   806,   808,   810,
   817,   825,   826,   828,   835,   836,   839,   841,   843,   845,
   847,   849,   851,   859,   867,   868,   871,   872,   875,   883,
   886,   888,   890,   891,   895,   901,   909,   913,   916,   918,
   920,   921,   925,   927,   929,   931,   933,   935,   937,   939,
   941,   943,   945,   947,   949,   951,   953,   955,   957,   959,
   962,   967,   970,   972,   973,   976,   978,   980,   982,   984,
   986,   988,   990,   991,  1007,  1008,  1011,  1012,  1015,  1016,
  1019,  1020,  1024,  1031,  1040,  1048,  1051,  1053,  1054,  1056,
  1060,  1061,  1063,  1067,  1071,  1073,  1077,  1079,  1083,  1085,
  1089,  1091,  1097,  1100,  1101,  1107,  1110,  1111,  1115,  1118,
  1119,  1122,  1124,  1126,  1129,  1130,  1132,  1133,  1135,  1144,
  1149,  1150,  1156,  1166,  1167,  1169,  1170,  1183,  1184,  1187,
  1188,  1190,  1191,  1194,  1195,  1199,  1202,  1203,  1207,  1209,
  1211,  1212,  1215,  1217,  1219,  1221,  1223,  1225,  1227,  1229,
  1231,  1233,  1235,  1237,  1239,  1245,  1246,  1249,  1250,  1253,
  1262,  1267,  1268,  1271,  1281,  1282,  1285,  1286,  1292,  1294,
  1295,  1305,  1306,  1308,  1309,  1312,  1317,  1322,  1323,  1326,
  1329,  1332,  1336,  1337,  1339,  1345,  1346,  1348,  1353,  1359,
  1360,  1363,  1364,  1367,  1368,  1371,  1372,  1383,  1384,  1393,
  1394,  1397,  1398,  1401,  1403,  1405,  1406,  1415,  1416,  1418,
  1419,  1422,  1425,  1430,  1434,  1436,  1438,  1440,  1442,  1444,
  1445,  1446,  1453,  1456,  1458,  1462,  1465,  1467,  1468
};

static const short yyrhs[] = {   114,
     0,     0,   122,     0,   112,     0,   111,     0,   109,     0,
   110,     0,   120,     0,    47,     0,   110,     0,   112,     0,
   119,   112,     0,     0,   109,     0,   109,   112,     0,   112,
     0,   121,   101,   112,     0,   123,   124,     0,     0,   123,
   125,     0,   129,     0,   143,     0,   147,     0,   139,     0,
   151,     0,   126,     0,   127,     0,    39,   121,   104,     0,
    73,   128,   104,     0,   201,     0,   128,   101,   201,     0,
     0,    26,   112,    37,   130,   131,   133,   135,   136,    25,
   137,   104,     0,     0,   132,     0,    32,   172,   104,     0,
     0,   134,     0,    55,   171,   104,     0,     0,   135,   156,
     0,     0,    12,   274,     0,    26,   138,     0,   138,     0,
     0,   112,     0,     0,     8,   112,    48,   112,    37,   140,
   141,    12,   274,    25,   142,   104,     0,     0,   141,   157,
     0,     8,   138,     0,   138,     0,     0,    19,   112,    48,
   112,    37,   144,   145,   350,    25,   146,   104,     0,     0,
   145,   162,     0,    19,   138,     0,   138,     0,     0,    54,
   112,    37,   148,   149,    25,   150,   104,     0,     0,   149,
   158,     0,    54,   138,     0,   138,     0,     0,    54,    14,
   112,    37,   152,   153,    25,   154,   104,     0,     0,   153,
   159,     0,    54,    14,   138,     0,   138,     0,   218,     0,
   238,     0,   249,     0,   257,     0,   256,     0,   163,     0,
   127,     0,   155,     0,   167,     0,   263,     0,   264,     0,
   260,     0,   250,     0,   155,     0,   167,     0,   348,     0,
   263,     0,   264,     0,   359,     0,   260,     0,   250,     0,
   155,     0,   348,     0,   263,     0,   264,     0,   260,     0,
   250,     0,   155,     0,   167,     0,   155,     0,   167,     0,
   263,     0,   264,     0,   252,     0,   155,     0,   167,     0,
   263,     0,   264,     0,   252,     0,   264,     0,   127,     0,
   164,   104,     0,   165,     0,    56,   112,   166,     0,    30,
   115,   166,    62,   189,     0,     0,   173,     0,     0,   164,
    37,   168,   170,    12,   317,    25,   169,   104,     0,     0,
   115,     0,     0,   170,   160,     0,   173,     0,   173,     0,
    99,   175,   174,   100,     0,     0,   174,   104,   175,     0,
   178,   121,   103,   177,   239,   176,   253,     0,     0,    15,
     0,     0,   179,     0,     0,   254,     0,    35,     0,    53,
     0,    36,     0,    15,     0,    40,     0,    99,   185,   182,
   100,     0,   180,     0,     0,   182,   101,   185,     0,    99,
   186,   184,   100,     0,     0,   184,   101,   186,     0,   187,
   105,   188,     0,   188,     0,   185,     0,   246,     0,   199,
     0,   191,     0,    50,     0,   112,     0,   201,     0,   191,
     0,   193,     0,   194,     0,   195,     0,   196,     0,   192,
    43,   192,     0,   192,    46,   192,     0,   196,     0,   192,
     7,   192,     0,   193,     7,   192,     0,   192,    51,   192,
     0,   194,    51,   192,     0,   192,    79,   192,     0,   195,
    79,   192,     0,   197,     0,    86,   198,     0,    87,   198,
     0,    95,   198,     0,    96,   198,     0,   198,    94,   198,
     0,   192,    92,   192,     0,   192,    93,   192,     0,   192,
    88,   192,     0,   192,    90,   192,     0,   192,    86,   192,
     0,   192,    87,   192,     0,   192,    83,   192,     0,   192,
    85,   192,     0,   192,    82,   192,     0,   192,    84,   192,
     0,   192,    80,   192,     0,   192,    81,   192,     0,   192,
    91,   192,     0,   199,     0,   116,     0,   208,     0,   210,
     0,   211,     0,    99,   190,   100,     0,   197,     0,   189,
     0,   200,     0,   111,     0,   205,     0,   204,     0,   199,
   108,   203,     0,   202,   108,   112,     0,   112,     0,   115,
     0,   110,     0,     6,     0,   189,   183,     0,   200,   183,
     0,   189,    98,   112,     0,   200,    98,   112,     0,   189,
    98,    58,     0,   200,    98,    58,     0,   205,   207,     0,
     0,    99,   190,   100,     0,   209,   100,     0,    99,   214,
   105,   190,   100,     0,    99,   213,   101,   213,     0,   209,
   101,   213,     0,   189,    98,    99,   190,   100,     0,   189,
    98,   208,     0,    44,   189,   189,   212,     0,    44,   189,
   212,     0,    44,   210,     0,     0,   183,     0,   214,   105,
   190,     0,   190,     0,   216,   215,     0,     0,   215,   107,
   216,     0,   191,     0,   246,     0,    52,     0,   112,     0,
    70,   217,   219,   104,     0,     0,    37,   220,     0,   221,
     0,   242,     0,   224,     0,   228,     0,   232,     0,   233,
     0,   236,     0,   237,     0,    99,   222,   100,     0,   117,
   223,     0,     0,   101,   222,     0,   242,    71,   226,   225,
    25,    71,     0,     0,   225,   227,     0,   112,   104,     0,
   112,    80,   118,   104,     0,     9,    99,   229,   100,    48,
   239,     0,   231,   230,     0,     0,   101,   231,   230,     0,
   189,    58,   106,     0,     9,   243,    48,   239,     0,    59,
   235,   234,    25,    59,     0,     0,   234,   235,     0,   121,
   103,   239,   104,     0,     3,   239,     0,    28,    48,   189,
     0,    66,   217,    37,   239,   104,     0,   189,   241,     0,
   240,     0,   189,   189,   242,     0,   189,   242,     0,   189,
   189,   241,     0,     0,   183,     0,    58,   247,     0,    99,
   245,   244,   100,     0,     0,   244,   101,   245,     0,   239,
     0,   247,     0,   240,     0,   190,   248,   190,     0,   206,
     0,   190,   248,   190,     0,    68,     0,    22,     0,    20,
   121,   103,   239,   253,   104,     0,    65,   121,   103,   239,
   251,   253,   104,     0,     0,   255,     0,    74,   121,   103,
   239,   253,   104,     0,     0,   102,   190,     0,    20,     0,
    65,     0,    74,     0,    28,     0,    16,     0,    60,     0,
     5,   112,   103,   239,    37,   199,   104,     0,    28,   112,
   103,   239,   258,   259,   104,     0,     0,    50,   190,     0,
     0,    37,   190,     0,    21,   261,   103,   189,     4,   190,
   104,     0,   199,   262,     0,    52,     0,     6,     0,     0,
   262,   101,   199,     0,    11,   112,   103,   189,   104,     0,
    11,   112,    48,   265,    37,   190,   104,     0,   266,   103,
   268,     0,   115,   267,     0,    52,     0,     6,     0,     0,
   267,   101,   115,     0,    26,     0,     8,     0,    54,     0,
    19,     0,    18,     0,    38,     0,    70,     0,    66,     0,
    56,     0,    30,     0,    65,     0,    74,     0,    20,     0,
   271,     0,   272,     0,   272,     0,   273,     0,    34,   190,
     0,    29,   112,    35,   245,     0,    77,   329,     0,   275,
     0,     0,   275,   276,     0,   277,     0,   289,     0,   290,
     0,   291,     0,   283,     0,   306,     0,   308,     0,     0,
   112,   103,    13,   282,   311,   278,   281,   280,   279,    12,
   274,    25,    13,   138,   104,     0,     0,   279,   157,     0,
     0,   134,   287,     0,     0,   132,   285,     0,     0,    99,
   329,   100,     0,   112,   103,   284,   285,   287,   104,     0,
   112,   103,   361,    32,    42,   181,   287,   104,     0,   112,
   103,   361,    55,    42,   181,   104,     0,    18,   189,     0,
   368,     0,     0,   286,     0,    32,    42,   181,     0,     0,
   288,     0,    55,    42,   181,     0,   112,   103,   320,     0,
   320,     0,   112,   103,   338,     0,   338,     0,   112,   103,
   292,     0,   292,     0,   112,   103,   303,     0,   303,     0,
   299,    83,   300,   293,   104,     0,   294,   295,     0,     0,
   294,   295,    76,   329,    23,     0,   297,   296,     0,     0,
   296,   101,   297,     0,   190,   298,     0,     0,     4,   190,
     0,   199,     0,   208,     0,   302,   301,     0,     0,    69,
     0,     0,    33,     0,    78,   190,    63,   299,    83,   300,
   304,   104,     0,   305,   295,    76,   214,     0,     0,   305,
   295,    76,   214,   101,     0,   112,   103,   269,    31,   274,
    25,    31,   307,   104,     0,     0,   112,     0,     0,   310,
    57,   313,   311,   309,   312,    12,   317,    25,    57,   138,
   104,     0,     0,   112,   103,     0,     0,    37,     0,     0,
   312,   161,     0,     0,    99,   314,   100,     0,   316,   315,
     0,     0,   315,   101,   316,     0,   199,     0,   318,     0,
     0,   318,   319,     0,   320,     0,   323,     0,   335,     0,
   326,     0,   330,     0,   334,     0,   337,     0,   338,     0,
   339,     0,   341,     0,   343,     0,   344,     0,    10,   329,
   322,   321,   104,     0,     0,    64,   190,     0,     0,    61,
   190,     0,    17,   190,    37,   324,   325,    25,    17,   104,
     0,    76,   214,   105,   317,     0,     0,   325,   324,     0,
    34,   329,    67,   317,   328,   327,    25,    34,   104,     0,
     0,    23,   317,     0,     0,   328,    24,   329,    67,   317,
     0,   190,     0,     0,   333,   332,    41,   331,   317,    25,
    41,   138,   104,     0,     0,   270,     0,     0,   112,   103,
     0,    45,   138,   336,   104,     0,    27,   138,   336,   104,
     0,     0,    76,   329,     0,    47,   104,     0,   199,   104,
     0,    62,   340,   104,     0,     0,   190,     0,   299,    83,
   342,   295,   104,     0,     0,    69,     0,   299,   102,   190,
   104,     0,    75,   347,   346,   345,   104,     0,     0,    29,
   190,     0,     0,    72,   329,     0,     0,    49,   314,     0,
     0,    18,   112,   311,   349,   131,   133,    25,    18,   138,
   104,     0,     0,    29,   199,   351,   353,   352,    25,    29,
   104,     0,     0,   352,   354,     0,     0,   353,   127,     0,
   350,     0,   355,     0,     0,    29,   360,   358,   356,   357,
    25,    29,   104,     0,     0,   350,     0,     0,   367,   104,
     0,   364,   104,     0,    29,   360,   363,   104,     0,   362,
   103,   361,     0,   189,     0,   121,     0,     6,     0,    52,
     0,   364,     0,     0,     0,   365,    73,   368,   366,   285,
   287,     0,   286,   287,     0,   288,     0,    26,   202,   369,
     0,    19,   189,     0,    50,     0,     0,    99,   112,   100,
     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   398,   401,   403,   406,   408,   411,   413,   414,   415,   418,
   420,   423,   428,   430,   433,   438,   440,   447,   451,   453,
   456,   458,   459,   460,   461,   464,   466,   469,   473,   477,
   479,   486,   494,   505,   507,   510,   518,   520,   523,   531,
   533,   536,   538,   541,   543,   546,   548,   551,   563,   573,
   574,   577,   579,   583,   595,   605,   606,   609,   611,   615,
   623,   630,   631,   634,   636,   640,   648,   655,   656,   659,
   661,   668,   670,   671,   672,   673,   674,   675,   678,   680,
   681,   682,   683,   684,   687,   689,   690,   691,   692,   693,
   694,   695,   698,   700,   701,   702,   703,   704,   707,   709,
   712,   714,   715,   716,   717,   720,   722,   723,   724,   725,
   728,   730,   737,   744,   755,   758,   762,   764,   767,   786,
   799,   801,   804,   806,   814,   825,   836,   850,   852,   865,
   875,   877,   880,   882,   885,   887,   890,   892,   893,   894,
   895,   898,   903,   910,   912,   917,   928,   930,   940,   945,
   954,   956,   959,   963,   965,   972,   974,   977,   984,   986,
   987,   988,   989,   991,   995,  1002,  1005,  1009,  1012,  1016,
  1019,  1024,  1026,  1028,  1030,  1032,  1034,  1039,  1042,  1044,
  1046,  1048,  1050,  1052,  1054,  1056,  1058,  1060,  1062,  1064,
  1068,  1070,  1071,  1072,  1073,  1074,  1077,  1084,  1086,  1089,
  1091,  1092,  1095,  1099,  1101,  1104,  1106,  1107,  1109,  1124,
  1140,  1143,  1145,  1147,  1151,  1160,  1162,  1166,  1171,  1177,
  1186,  1196,  1199,  1204,  1210,  1215,  1229,  1231,  1238,  1241,
  1245,  1256,  1258,  1271,  1281,  1285,  1295,  1299,  1307,  1309,
  1312,  1314,  1315,  1316,  1317,  1318,  1319,  1320,  1323,  1332,
  1336,  1338,  1341,  1362,  1364,  1374,  1383,  1394,  1401,  1412,
  1417,  1427,  1434,  1441,  1448,  1453,  1459,  1469,  1480,  1494,
  1504,  1506,  1509,  1511,  1512,  1515,  1517,  1520,  1524,  1535,
  1540,  1550,  1561,  1567,  1578,  1584,  1607,  1613,  1615,  1622,
  1635,  1646,  1648,  1651,  1661,  1663,  1666,  1668,  1669,  1670,
  1673,  1675,  1678,  1685,  1693,  1698,  1706,  1711,  1719,  1726,
  1728,  1729,  1732,  1734,  1741,  1759,  1766,  1773,  1778,  1782,
  1788,  1790,  1796,  1798,  1799,  1800,  1801,  1802,  1803,  1804,
  1805,  1806,  1807,  1808,  1809,  1816,  1818,  1821,  1823,  1826,
  1833,  1838,  1846,  1850,  1852,  1862,  1864,  1865,  1866,  1867,
  1868,  1873,  1876,  1888,  1904,  1906,  1909,  1911,  1914,  1916,
  1919,  1921,  1924,  1935,  1945,  1958,  1963,  1966,  1968,  1971,
  1975,  1977,  1980,  1984,  1989,  1997,  2002,  2007,  2013,  2018,
  2024,  2031,  2038,  2051,  2053,  2065,  2077,  2079,  2089,  2096,
  2098,  2101,  2103,  2106,  2110,  2112,  2115,  2117,  2120,  2124,
  2128,  2130,  2133,  2139,  2141,  2144,  2153,  2169,  2171,  2174,
  2176,  2179,  2181,  2184,  2186,  2189,  2197,  2199,  2206,  2223,
  2227,  2229,  2239,  2241,  2242,  2243,  2244,  2245,  2246,  2247,
  2248,  2249,  2250,  2251,  2254,  2262,  2267,  2274,  2279,  2286,
  2301,  2308,  2313,  2323,  2339,  2341,  2344,  2346,  2361,  2365,
  2371,  2377,  2379,  2382,  2384,  2387,  2394,  2401,  2403,  2406,
  2410,  2426,  2453,  2455,  2458,  2465,  2467,  2470,  2477,  2484,
  2486,  2489,  2491,  2494,  2496,  2503,  2512,  2521,  2524,  2535,
  2537,  2540,  2542,  2545,  2547,  2550,  2554,  2564,  2566,  2569,
  2571,  2572,  2575,  2584,  2592,  2597,  2599,  2600,  2607,  2611,
  2613,  2615,  2622,  2628,  2635,  2638,  2640,  2644,  2646
};

static const char * const yytname[] = {   "$","error","$illegal.","t_ACCESS",
"t_AFTER","t_ALIAS","t_ALL","t_AND","t_ARCHITECTURE","t_ARRAY","t_ASSERT","t_ATTRIBUTE",
"t_BEGIN","t_BLOCK","t_BODY","t_BUFFER","t_BUS","t_CASE","t_COMPONENT","t_CONFIGURATION",
"t_CONSTANT","t_DISCONNECT","t_DOWNTO","t_ELSE","t_ELSIF","t_END","t_ENTITY",
"t_EXIT","t_FILE","t_FOR","t_FUNCTION","t_GENERATE","t_GENERIC","t_GUARDED",
"t_IF","t_IN","t_INOUT","t_IS","t_LABEL","t_LIBRARY","t_LINKAGE","t_LOOP","t_MAP",
"t_NAND","t_NEW","t_NEXT","t_NOR","t_NULL","t_OF","t_ON","t_OPEN","t_OR","t_OTHERS",
"t_OUT","t_PACKAGE","t_PORT","t_PROCEDURE","t_PROCESS","t_RANGE","t_RECORD",
"t_REGISTER","t_REPORT","t_RETURN","t_SELECT","t_SEVERITY","t_SIGNAL","t_SUBTYPE",
"t_THEN","t_TO","t_TRANSPORT","t_TYPE","t_UNITS","t_UNTIL","t_USE","t_VARIABLE",
"t_WAIT","t_WHEN","t_WHILE","t_WITH","t_XOR","t_EQSym","t_NESym","t_LTSym","t_LESym",
"t_GTSym","t_GESym","t_Plus","t_Minus","t_Ampersand","MED_PRECEDENCE","t_Star",
"t_Slash","t_MOD","t_REM","t_DoubleStar","t_ABS","t_NOT","MAX_PRECEDENCE","t_Apostrophe",
"t_LeftParen","t_RightParen","t_Comma","t_VarAsgn","t_Colon","t_Semicolon","t_Arrow",
"t_Box","t_Bar","t_Dot","t_AbstractLit","t_CharacterLit","t_StringLit","t_Identifier",
"start","opt_design_unit","designator","literal","enumeration_literal","physical_literal",
"opt_t_AbstractLit","physical_literal_no_default","idf_list","design_unit","context_list",
"lib_unit","context_item","lib_clause","use_clause","sel_list","entity_declaration",
"@1","opt_generic_clause","generic_clause","opt_port_clause","port_clause","entity_decl_part",
"opt_entity_stats","opt_entity_end","opt_t_Identifier","architecture_body","@2",
"architecture_decl_part","opt_architecture_end","configuration_declaration",
"@3","configuration_decl_part","opt_configuration_end","package_declaration",
"@4","package_decl_part","opt_package_end","package_body","@5","package_body_decl_part",
"opt_package_body_end","common_decltve_item","entity_decltve_item","block_decltve_item",
"package_decltve_item","package_body_decltve_item","subprog_decltve_item","proc_decltve_item",
"config_decltve_item","subprog_decl","subprog_spec","proc_or_func_spec","opt_interf_list",
"subprog_body","@6","opt_designator","subprog_body_decl_part","port_interf_list",
"generic_interf_list","interf_list","opt_more_interf_elements","interf_element",
"opt_t_BUFFER","opt_mode","opt_object_class","mode","association_list","named_association_list",
"association_list_1","gen_association_list","gen_association_list_1","association_element",
"gen_association_element","formal_part","actual_part","mark","expr","expr_or_attr",
"relation","and_relation","or_relation","xor_relation","relation_or_attr","primary_or_attr",
"primary","name","name2","sel_name","simple_sel_name","suffix","ifts_name","attribute_name",
"attribute_name_with_param","opt_attribute_param","aggregate","rev_element_association_list2",
"qualified_expr","allocator","opt_index_association_list","element_association",
"choices","opt_more_choices","choice","decl_Identifier","type_decl","opt_type_def",
"type_definition","enumeration_type_definition","enumeration_literal_decls",
"opt_more_enumeration_literals","physical_type_definition","secondary_unit_decls",
"primary_unit_decl","secondary_unit_decl","unconstrained_array_definition","index_subtype_defs",
"opt_more_index_subtype_defs","index_subtype_definition","constrained_array_definition",
"record_type_definition","opt_more_element_decls","element_decl","access_type_definition",
"file_type_definition","subtype_decl","subtype_indic","subtype_indic1","opt_index_constraint",
"range_constraint","index_constraint","opt_more_discrete_ranges","discrete_range",
"discrete_range1","range_spec","direction","constant_decl","signal_decl","opt_signal_kind",
"variable_decl","opt_var_init","object_class","signal_kind","alias_decl","file_decl",
"opt_open_mode","opt_file_name","disconnection_spec","signal_list","opt_more_signal_list",
"attribute_decl","attribute_spec","entity_spec","entity_name_list","opt_more_entity_name_list",
"entity_class","generation_scheme","iteration_scheme","if_scheme","for_scheme",
"while_scheme","concurrent_stats","reverse_concurrent_stats","concurrent_stat",
"block_stat","@7","block_decl_part","block_port_stuff","block_generic_stuff",
"block_guard","comp_inst_stat","comp_inst_unit","opt_generic_map","generic_map",
"opt_port_map","port_map","concurrent_assertion_stat","concurrent_procedure_call",
"concurrent_signal_assign_stat","condal_signal_assign","condal_wavefrms","condal_wavefrms_1",
"wavefrm","reverse_more_wavefrm","wavefrm_element","opt_wavefrm_after","target",
"opts","opts_2","opts_1","sel_signal_assign","sel_wavefrms","sel_wavefrms_1",
"generate_stat","generate_stat_1","proc_stat","@8","opt_proc_label","opt_t_IS",
"proc_decl_part","opt_proc_sensitivity_list","sensitivity_list","reverse_opt_more_sensitivities",
"signal_name","seq_stats","rev_seq_stats","seq_stat","assertion_stat","opt_assertion_severity",
"opt_assertion_report","case_stat","case_stat_alternative","more_case_stat_alternatives",
"if_stat","if_stat_2","if_stat_1","condition","loop_stat","@9","opt_iteration_scheme",
"opt_label","next_stat","exit_stat","opt_when","null_stat","procedure_call_stat",
"return_stat","opt_expr","signal_assign_stat","opt_t_TRANSPORT","variable_assign_stat",
"wait_stat","opt_wait_for","opt_wait_until","opt_wait_on","comp_decl","@10",
"block_config","@11","config_items","use_clauses","config_item","comp_config",
"@12","opt_block_config","opt_comp_binding_indic","config_spec","comp_spec",
"comp_mark","inst_list","binding_indic","pre_binding_indic","@13","@14","incremental_binding_indic",
"entity_aspect","opt_arch_id",""
};
#endif

static const short yyr1[] = {     0,
   113,   114,   114,   115,   115,   116,   116,   116,   116,   117,
   117,   118,   119,   119,   120,   121,   121,   122,   123,   123,
   124,   124,   124,   124,   124,   125,   125,   126,   127,   128,
   128,   130,   129,   131,   131,   132,   133,   133,   134,   135,
   135,   136,   136,   137,   137,   138,   138,   140,   139,   141,
   141,   142,   142,   144,   143,   145,   145,   146,   146,   148,
   147,   149,   149,   150,   150,   152,   151,   153,   153,   154,
   154,   155,   155,   155,   155,   155,   155,   155,   156,   156,
   156,   156,   156,   156,   157,   157,   157,   157,   157,   157,
   157,   157,   158,   158,   158,   158,   158,   158,   159,   159,
   160,   160,   160,   160,   160,   161,   161,   161,   161,   161,
   162,   162,   163,   164,   165,   165,   166,   166,   168,   167,
   169,   169,   170,   170,   171,   172,   173,   174,   174,   175,
   176,   176,   177,   177,   178,   178,   179,   179,   179,   179,
   179,   180,   181,   182,   182,   183,   184,   184,   185,   185,
   186,   186,   187,   188,   188,   189,   189,   190,   191,   191,
   191,   191,   191,   191,   192,   193,   193,   194,   194,   195,
   195,   196,   196,   196,   196,   196,   196,   196,   196,   196,
   196,   196,   196,   196,   196,   196,   196,   196,   196,   196,
   197,   197,   197,   197,   197,   197,   198,   199,   199,   200,
   200,   200,   201,   202,   202,   203,   203,   203,   204,   204,
   205,   205,   205,   205,   206,   207,   207,   208,   208,   209,
   209,   210,   210,   211,   211,   211,   212,   212,   213,   213,
   214,   215,   215,   216,   216,   216,   217,   218,   219,   219,
   220,   220,   220,   220,   220,   220,   220,   220,   221,   222,
   223,   223,   224,   225,   225,   226,   227,   228,   229,   230,
   230,   231,   232,   233,   234,   234,   235,   236,   237,   238,
   239,   239,   240,   240,   240,   241,   241,   242,   243,   244,
   244,   245,   245,   246,   246,   247,   247,   248,   248,   249,
   250,   251,   251,   252,   253,   253,   254,   254,   254,   254,
   255,   255,   256,   257,   258,   258,   259,   259,   260,   261,
   261,   261,   262,   262,   263,   264,   265,   266,   266,   266,
   267,   267,   268,   268,   268,   268,   268,   268,   268,   268,
   268,   268,   268,   268,   268,   269,   269,   270,   270,   271,
   272,   273,   274,   275,   275,   276,   276,   276,   276,   276,
   276,   276,   278,   277,   279,   279,   280,   280,   281,   281,
   282,   282,   283,   283,   283,   284,   284,   285,   285,   286,
   287,   287,   288,   289,   289,   290,   290,   291,   291,   291,
   291,   292,   293,   294,   294,   295,   296,   296,   297,   298,
   298,   299,   299,   300,   301,   301,   302,   302,   303,   304,
   305,   305,   306,   307,   307,   309,   308,   310,   310,   311,
   311,   312,   312,   313,   313,   314,   315,   315,   316,   317,
   318,   318,   319,   319,   319,   319,   319,   319,   319,   319,
   319,   319,   319,   319,   320,   321,   321,   322,   322,   323,
   324,   325,   325,   326,   327,   327,   328,   328,   329,   331,
   330,   332,   332,   333,   333,   334,   335,   336,   336,   337,
   338,   339,   340,   340,   341,   342,   342,   343,   344,   345,
   345,   346,   346,   347,   347,   349,   348,   351,   350,   352,
   352,   353,   353,   354,   354,   356,   355,   357,   357,   358,
   358,   358,   359,   360,   361,   362,   362,   362,   363,   365,
   366,   364,   367,   367,   368,   368,   368,   369,   369
};

static const short yyr2[] = {     0,
     1,     0,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     0,     1,     2,     1,     3,     2,     0,     2,
     1,     1,     1,     1,     1,     1,     1,     3,     3,     1,
     3,     0,    11,     0,     1,     3,     0,     1,     3,     0,
     2,     0,     2,     2,     1,     0,     1,     0,    12,     0,
     2,     2,     1,     0,    11,     0,     2,     2,     1,     0,
     8,     0,     2,     2,     1,     0,     9,     0,     2,     3,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     2,     1,     3,     5,     0,     1,     0,     9,
     0,     1,     0,     2,     1,     1,     4,     0,     3,     7,
     0,     1,     0,     1,     0,     1,     1,     1,     1,     1,
     1,     4,     1,     0,     3,     4,     0,     3,     3,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     3,     3,     1,     3,     3,     3,     3,     3,
     3,     1,     2,     2,     2,     2,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     1,     1,     1,     1,     1,     3,     1,     1,     1,     1,
     1,     1,     3,     3,     1,     1,     1,     1,     2,     2,
     3,     3,     3,     3,     2,     0,     3,     2,     5,     4,
     3,     5,     3,     4,     3,     2,     0,     1,     3,     1,
     2,     0,     3,     1,     1,     1,     1,     4,     0,     2,
     1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
     0,     2,     6,     0,     2,     2,     4,     6,     2,     0,
     3,     3,     4,     5,     0,     2,     4,     2,     3,     5,
     2,     1,     3,     2,     3,     0,     1,     2,     4,     0,
     3,     1,     1,     1,     3,     1,     3,     1,     1,     6,
     7,     0,     1,     6,     0,     2,     1,     1,     1,     1,
     1,     1,     7,     7,     0,     2,     0,     2,     7,     2,
     1,     1,     0,     3,     5,     7,     3,     2,     1,     1,
     0,     3,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
     4,     2,     1,     0,     2,     1,     1,     1,     1,     1,
     1,     1,     0,    15,     0,     2,     0,     2,     0,     2,
     0,     3,     6,     8,     7,     2,     1,     0,     1,     3,
     0,     1,     3,     3,     1,     3,     1,     3,     1,     3,
     1,     5,     2,     0,     5,     2,     0,     3,     2,     0,
     2,     1,     1,     2,     0,     1,     0,     1,     8,     4,
     0,     5,     9,     0,     1,     0,    12,     0,     2,     0,
     1,     0,     2,     0,     3,     2,     0,     3,     1,     1,
     0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     5,     0,     2,     0,     2,     8,
     4,     0,     2,     9,     0,     2,     0,     5,     1,     0,
     9,     0,     1,     0,     2,     4,     4,     0,     2,     2,
     2,     3,     0,     1,     5,     0,     1,     4,     5,     0,
     2,     0,     2,     0,     2,     0,    10,     0,     8,     0,
     2,     0,     2,     1,     1,     0,     8,     0,     1,     0,
     2,     2,     4,     3,     1,     1,     1,     1,     1,     0,
     0,     6,     2,     1,     3,     2,     1,     0,     3
};

static const short yydefact[] = {    19,
     1,     3,     0,     0,     0,     0,     0,     0,     0,    18,
    20,    26,    27,    21,    24,    22,    23,    25,     0,     0,
     0,    16,     0,     0,     0,   200,   156,     0,   198,     0,
   199,   157,   202,   201,     0,     0,    32,     0,    28,     0,
    60,     0,    29,     0,     0,   209,     0,     0,   210,     0,
     0,    34,    17,    66,    62,   157,   213,   211,     0,     9,
   155,     0,     0,     0,     0,     0,     6,     7,   192,     8,
   151,   147,     0,   150,   198,     0,   154,     0,   159,   160,
   161,   162,   172,     0,   191,   157,   193,     0,   194,   195,
   284,   152,   208,   207,     5,     4,   206,   203,   214,   212,
    48,    54,     0,    37,    35,    68,     0,   227,   226,   198,
   197,   173,   191,   174,   175,   176,   236,   230,   158,     0,
     0,   232,   235,    15,     0,     0,     0,     0,   276,   274,
   289,   288,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   218,     0,    50,    56,   135,
     0,   126,     0,    40,    38,     0,     0,     0,     0,     0,
     0,    46,     0,     0,     0,     0,     0,     0,    78,    93,
    63,    77,     0,   114,    72,    73,    74,    98,    76,    75,
    97,    95,    96,    94,   228,   227,   225,   196,     0,     0,
   231,   146,     0,   149,   154,     0,   158,   201,   286,   278,
     0,   223,   209,   275,   273,   285,   166,   165,   163,   164,
   168,   170,   188,   189,   186,   184,   187,   185,   182,   183,
   180,   181,   190,   178,   179,   167,   169,   171,   177,   230,
   221,     0,     0,     0,   297,   300,   298,   299,   128,     0,
   136,    36,     0,   125,    42,    46,    99,    69,     0,   100,
     0,     0,   410,     0,   312,   311,   313,     0,    46,    47,
    65,     0,     0,   117,   117,     0,   237,     0,   239,   113,
   224,   220,   229,     0,   148,     0,     0,   215,   230,     0,
   344,     0,    85,    51,    86,    92,    91,    88,    89,    87,
    90,     0,     0,   112,    57,   111,     0,     0,     0,    39,
   344,     0,    79,    41,    80,    84,    83,    81,    82,     0,
    71,     0,   119,     0,     0,     0,   411,   476,     0,   310,
     0,    64,    61,     0,     0,   118,   115,     0,     0,     0,
     0,   219,   233,   287,     0,   222,   229,     0,   343,   497,
   498,   496,   500,     0,     0,   478,    46,   127,   135,   133,
    43,    46,    46,    67,   123,   276,     0,   272,   320,   319,
   321,     0,     0,   198,    34,   295,     0,   198,   305,     0,
   292,     0,     0,     0,     0,     0,     0,   240,   241,   243,
   244,   245,   246,   247,   248,   242,   238,   217,    46,     0,
     0,     0,   156,   392,   393,   345,   346,   350,   347,   348,
   349,   379,     0,   381,   351,   352,     0,   375,   377,     0,
   499,     0,     0,   482,    46,    59,     0,   129,   140,   137,
   139,   141,   138,     0,   134,    46,     0,    45,    70,     0,
   271,     0,   318,     0,     0,   315,    37,     0,     0,   314,
     0,     0,   307,   116,   301,   302,   295,   293,   270,   268,
     0,     0,     0,     0,   265,    10,    11,   251,     0,     0,
    46,    53,     0,   449,   438,     0,   409,   461,   397,   414,
   493,     0,   495,   494,   480,    58,    55,   131,    44,    33,
   421,     0,   101,   124,   102,   105,   103,   104,     0,     0,
     0,   324,   327,   326,   335,   323,   332,   328,   325,   331,
   333,   330,   329,   334,   317,     0,   296,   290,     0,   306,
     0,     0,     0,   198,     0,   260,   282,   280,   283,     0,
   198,     0,     0,     0,   250,   249,     0,   254,    52,    49,
     0,   436,     0,   361,     0,     0,     0,     0,     0,   507,
     0,   336,   337,   368,   378,   380,   374,   376,     0,   367,
   398,   384,   395,     0,   410,   501,   483,     0,   132,   295,
     0,   420,     0,   303,   322,   316,     0,   309,   308,   304,
   291,     0,     0,     0,   259,     0,   263,     0,     0,   266,
   252,   256,     0,   439,     0,     0,   392,     0,     0,   410,
   366,   506,   205,   508,     0,   340,   344,     0,   371,   369,
     0,     0,     0,     0,   396,   394,   419,     0,   417,   406,
   368,     0,     0,   484,   481,   485,   130,   121,     0,    46,
     0,    46,     0,   463,   474,   156,     0,   422,   423,   424,
   426,   427,   452,   428,   425,   429,   430,   431,   432,   433,
   434,     0,    46,   262,     0,   198,   260,   279,     0,   267,
   264,     0,     0,   255,   437,   435,   397,     0,   353,     0,
     0,   505,     0,     0,     0,     0,     0,   372,     0,     0,
   382,   390,   383,   387,   415,   416,   412,   371,     0,   156,
   490,   122,     0,     0,   458,     0,   458,   460,   464,     0,
     0,   472,   455,   466,     0,     0,   453,   338,   339,     0,
   295,     0,   258,     0,   261,   198,   281,   253,    13,   401,
   362,   359,     0,   204,   341,     0,     0,   143,   370,     0,
   363,   371,     0,     0,   389,     0,   386,     0,     0,   502,
   479,   371,   504,   486,     0,     0,   120,     0,     0,     0,
   421,     0,   462,   475,     0,   470,   467,     0,     0,   342,
   450,     0,   477,    14,     0,     0,     0,     0,   368,   357,
   509,   404,   144,   373,     0,   365,   391,     0,     0,   418,
   421,   106,   413,   107,   110,   108,   109,   503,   488,   492,
   491,     0,   442,   459,   457,   447,   456,   473,     0,     0,
     0,   468,   421,   294,   257,    12,   399,     0,   360,   371,
   355,   405,     0,     0,   364,   385,   388,     0,   489,     0,
     0,     0,   445,   471,   469,   465,     0,     0,   358,     0,
   403,   142,     0,     0,     0,   421,     0,   443,   421,     0,
     0,     0,   400,   344,   356,   145,    46,     0,   441,     0,
   446,     0,     0,    46,   402,     0,     0,   487,   440,   421,
     0,     0,     0,   407,   448,   444,   451,    46,     0,   354,
     0,     0,     0
};

static const short yydefgoto[] = {   871,
     1,    97,    69,   468,   765,   766,    70,   352,     2,     3,
    10,    11,    12,   179,    28,    14,    52,   104,   105,   164,
   165,   255,   312,   437,   271,    15,   158,   243,   473,    16,
   159,   244,   427,    17,    55,   107,   272,    18,   106,   166,
   322,   293,   314,   294,   181,   258,   494,   783,   305,   182,
   259,   184,   335,   295,   365,   693,   440,   253,   161,   336,
   308,   249,   570,   434,   250,   435,   728,   729,   814,    46,
   125,    71,    72,    73,    74,   110,   474,   207,    78,    79,
    80,    81,    82,    83,    84,   113,    31,    86,   604,    98,
    33,    34,   209,   288,    87,    88,    89,    90,   197,   120,
   121,   201,   122,   278,   185,   341,   388,   389,   469,   535,
   390,   593,   538,   664,   391,   525,   585,   526,   392,   393,
   533,   465,   394,   395,   186,   527,   368,   441,   130,   462,
   586,   528,   123,   529,   133,   187,   296,   457,   496,   449,
   251,   458,   189,   190,   453,   522,   297,   268,   330,   298,
   299,   372,   373,   443,   515,   551,   707,   552,   553,   709,
   348,   349,   406,   407,   722,   830,   811,   770,   600,   408,
   554,   609,   610,   677,   678,   409,   410,   411,   412,   613,
   614,   683,   737,   684,   735,   413,   562,   616,   563,   414,
   767,   768,   415,   813,   416,   687,   417,   328,   739,   565,
   618,   686,   619,   571,   572,   638,   418,   596,   542,   640,
   793,   822,   641,   841,   823,   475,   642,   803,   710,   643,
   644,   645,   750,   646,   419,   648,   700,   649,   758,   650,
   651,   800,   756,   702,   300,   375,   307,   424,   568,   485,
   625,   626,   789,   820,   744,   301,   353,   484,   354,   420,
   421,   422,   621,   746,   560,   672
};

static const short yypact[] = {    71,
-32768,-32768,   293,   -35,   104,   136,   159,    25,   378,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   113,   228,
   245,-32768,   261,   209,   251,-32768,-32768,   271,   397,   226,
   426,   281,-32768,-32768,   238,   243,-32768,   272,-32768,   365,
-32768,   378,-32768,    56,   509,-32768,    24,   134,-32768,   379,
   385,   375,-32768,-32768,-32768,   311,-32768,-32768,   378,-32768,
-32768,   153,   153,   153,   153,   859,   320,-32768,-32768,-32768,
-32768,-32768,   347,-32768,   312,    50,   141,   659,   448,   411,
   401,   729,   399,   412,   323,-32768,-32768,   427,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   392,   454,-32768,-32768,   910,   418,-32768,   433,
-32768,-32768,   226,-32768,-32768,-32768,-32768,    57,   219,   410,
   409,-32768,-32768,-32768,   464,   509,   905,    91,   328,-32768,
-32768,-32768,   905,   905,   905,   905,   905,   905,   905,   905,
   905,   905,   905,   905,   905,   905,   905,   905,   905,   905,
   905,   905,   905,   905,   153,-32768,   859,-32768,-32768,   222,
   415,-32768,   392,-32768,-32768,   286,   421,   423,   432,   159,
    53,   -14,   434,   458,   442,   159,   450,   450,-32768,-32768,
-32768,-32768,   462,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   123,   171,-32768,-32768,   859,   905,
   431,-32768,   509,-32768,-32768,    50,-32768,   403,-32768,-32768,
   859,-32768,   552,-32768,-32768,-32768,   959,-32768,   959,   959,
   959,   959,  1037,  1037,  1037,  1037,  1037,  1037,   459,   459,
   459,-32768,-32768,-32768,-32768,   959,   959,   959,-32768,    50,
-32768,   477,   834,   176,-32768,-32768,-32768,-32768,-32768,   159,
-32768,-32768,   474,-32768,   657,     0,-32768,-32768,     6,-32768,
   481,    49,   548,   -25,-32768,-32768,   226,   483,   476,-32768,
-32768,   486,   488,   392,   392,   132,-32768,   555,   560,-32768,
-32768,-32768,   498,   859,-32768,   905,   905,-32768,   161,   905,
-32768,    32,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   489,   378,-32768,-32768,-32768,   575,   263,   197,-32768,
-32768,   578,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   592,
-32768,   503,-32768,   378,    69,   378,-32768,-32768,   378,   508,
   378,-32768,-32768,   378,   549,-32768,-32768,   378,   378,   208,
   506,-32768,-32768,-32768,   515,-32768,-32768,   591,   181,-32768,
-32768,   516,-32768,   519,   576,   226,    33,-32768,   222,   406,
-32768,    42,   476,-32768,-32768,   279,   588,-32768,-32768,-32768,
-32768,   589,   524,   204,   375,   527,   378,    43,   581,   378,
    51,   528,   378,   537,   593,   159,   327,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,   569,-32768,-32768,    19,   905,
   905,   859,   539,   289,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,   562,-32768,-32768,-32768,   590,-32768,-32768,   544,
-32768,   577,   378,-32768,   476,-32768,   545,-32768,-32768,-32768,
-32768,-32768,-32768,   378,-32768,   476,   547,-32768,-32768,   774,
-32768,   378,   554,   905,  1000,-32768,   454,   905,   556,   226,
   905,   905,   624,   171,-32768,-32768,   527,-32768,-32768,-32768,
   905,   615,   378,   355,-32768,-32768,-32768,   563,   565,   559,
   476,-32768,   572,-32768,   612,   616,   370,-32768,   647,   582,
-32768,   194,   414,-32768,   609,-32768,-32768,   669,-32768,-32768,
-32768,   159,-32768,-32768,-32768,-32768,-32768,-32768,   301,   458,
   585,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,   661,-32768,-32768,   586,-32768,
   905,   587,   594,   387,   595,   596,-32768,-32768,-32768,   378,
   229,   378,     3,   327,-32768,-32768,   597,-32768,-32768,-32768,
   905,   630,   249,   600,   378,   378,   584,   599,   905,-32768,
   672,-32768,-32768,   668,-32768,-32768,-32768,-32768,   164,-32768,
-32768,-32768,   637,   378,   548,-32768,-32768,    79,-32768,   527,
   683,   198,   364,-32768,-32768,-32768,   691,-32768,-32768,-32768,
-32768,   878,   664,   378,-32768,   471,-32768,   610,   656,-32768,
-32768,-32768,     4,-32768,   905,   613,   226,   636,   905,   548,
   171,   171,-32768,   196,   685,-32768,-32768,   679,   670,-32768,
   682,   684,   628,   905,-32768,-32768,   226,   634,-32768,-32768,
   668,   699,    77,-32768,-32768,-32768,-32768,   458,   905,   476,
   905,   476,   631,   905,   688,   651,   121,-32768,-32768,-32768,
-32768,-32768,    12,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,   378,   476,-32768,   378,   179,   596,-32768,   905,-32768,
-32768,   687,   675,-32768,-32768,-32768,   647,   660,-32768,   644,
   649,-32768,   905,   734,   663,   722,   662,-32768,   663,   663,
-32768,   761,   692,-32768,-32768,   673,-32768,   670,   665,   374,
   258,-32768,   666,   736,   695,   709,   695,-32768,-32768,   677,
   378,   705,-32768,   713,   905,   905,-32768,-32768,-32768,   742,
   527,   686,-32768,   681,-32768,   372,-32768,-32768,   694,-32768,
-32768,   375,   693,-32768,-32768,   757,   509,-32768,-32768,   663,
-32768,   670,   696,   905,-32768,   905,   700,   378,   821,-32768,
-32768,   670,-32768,-32768,   701,   702,-32768,   716,   905,   714,
-32768,   719,-32768,-32768,   905,   766,-32768,   905,   721,-32768,
-32768,   724,-32768,-32768,   725,   723,   727,   905,   668,   454,
-32768,   726,-32768,-32768,   730,-32768,-32768,   773,   905,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   768,-32768,
-32768,   859,-32768,-32768,-32768,-32768,-32768,-32768,   905,   732,
   733,-32768,-32768,-32768,-32768,-32768,-32768,   777,-32768,   670,
-32768,-32768,   738,   473,-32768,-32768,-32768,   825,-32768,   831,
   752,    44,   553,-32768,-32768,-32768,   833,   859,-32768,   854,
-32768,-32768,   509,   803,   832,-32768,   850,-32768,-32768,   905,
   843,   828,   769,-32768,-32768,-32768,   476,   767,-32768,   772,
-32768,   806,   844,   476,-32768,   855,   775,-32768,-32768,-32768,
   781,   782,   868,-32768,-32768,-32768,-32768,   476,   784,-32768,
   889,   892,-32768
};

static const short yypgoto[] = {-32768,
-32768,  -149,-32768,-32768,-32768,-32768,-32768,     8,-32768,-32768,
-32768,-32768,-32768,     9,-32768,-32768,-32768,   518,   174,   451,
   127,-32768,-32768,-32768,  -224,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,  -105,-32768,    72,-32768,-32768,-32768,-32768,-32768,-32768,
   794,-32768,   633,  -159,-32768,-32768,-32768,-32768,-32768,   -54,
-32768,   546,-32768,-32768,-32768,-32768,-32768,  -473,-32768,   -23,
-32768,  -709,   706,-32768,   786,    15,    -1,   -44,   941,-32768,
-32768,-32768,   962,    30,    38,    -9,-32768,    46,-32768,-32768,
-32768,  -116,-32768,-32768,  -108,-32768,   857,-32768,   717,    73,
  -153,-32768,   639,   739,-32768,-32768,-32768,-32768,   380,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,   269,   334,-32768,-32768,
-32768,   396,-32768,-32768,-32768,  -276,   -29,   804,  -112,-32768,
-32768,  -586,   -26,  -121,   728,-32768,   -86,-32768,   193,  -443,
-32768,-32768,-32768,-32768,-32768,-32768,   -84,-32768,-32768,  -102,
  -104,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   294,-32768,
  -302,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,  -590,   248,  -662,   250,-32768,-32768,-32768,   465,-32768,
-32768,  -484,-32768,   157,-32768,  -348,   276,-32768,-32768,   467,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,  -509,-32768,-32768,
   246,-32768,   210,  -717,-32768,-32768,  -442,-32768,-32768,-32768,
   128,-32768,-32768,-32768,-32768,  -589,-32768,-32768,-32768,-32768,
-32768,-32768,   254,-32768,  -426,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,   846,-32768,  -555,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,   333,   480,-32768,-32768,
   268,-32768,-32768,-32768,   478,-32768
};


#define	YYLAST		1130


static const short yytable[] = {    30,
    77,   180,   193,   242,   192,   210,   260,    49,   361,   668,
   208,    13,   624,   523,    23,    91,   215,   773,    92,   212,
   188,   119,   191,    29,   274,   740,   471,   589,   662,    93,
   688,   321,    30,   796,   557,    85,    91,   350,    24,   269,
   548,   696,   323,    76,   332,   242,   451,   367,   162,    30,
   558,   425,   376,   320,    32,   620,    29,   379,   265,    75,
   257,   381,   382,   818,   118,    30,   455,   436,   837,   775,
    -2,   131,   717,   108,   369,    38,    19,   329,   131,   788,
    75,   205,   350,   351,   195,   827,   725,    56,   706,   129,
   669,   111,   111,   111,   111,   315,   325,   270,    30,   112,
   114,   115,   116,   622,   266,   213,   460,   623,   254,   280,
   456,   270,   119,    57,    22,   663,   760,   132,   849,   792,
   370,   851,   196,   846,   132,   206,   627,    91,   351,   639,
   270,   216,   426,    94,    95,    96,    25,   438,   439,   306,
    44,    45,   865,    22,   270,   647,   778,   829,    57,   313,
   319,   326,   318,   270,   119,   240,   198,   488,    77,   794,
    35,   267,  -158,    26,    27,   798,   119,    58,   316,    91,
   317,    75,   195,    91,   472,   371,    92,   264,   809,    95,
    96,    91,   131,   276,   111,    29,   302,    26,   690,   211,
   400,    99,   239,    85,   598,   611,    59,   240,   283,    60,
   486,    76,    58,   704,   303,   732,   733,   400,  -158,   289,
   383,   489,   546,    75,   629,    20,   384,    75,   612,   547,
  -209,  -209,   705,   637,   630,    75,  -454,   396,   132,   241,
  -209,   631,    38,   819,   338,   385,   714,  -408,  -454,   119,
   405,   245,   632,   550,   633,   100,   539,    21,     9,   246,
   852,    66,   304,   587,    91,   588,   774,   309,   401,   634,
   346,    67,    68,    26,    27,   127,   386,   762,    44,    45,
    22,   282,   635,   801,  -454,    36,    44,    45,  -198,   402,
   495,    37,    76,   808,   344,   345,   247,    41,   347,   608,
   167,    26,   403,   356,   670,   248,   402,    38,    75,   360,
     4,    44,    45,   671,   674,   170,   387,   446,    26,   636,
   256,     5,   676,   173,    30,   174,    30,    29,     6,    30,
    40,    30,  -234,  -234,    30,  -234,    44,    45,    30,    30,
  -500,     7,  -269,    47,   493,   498,   127,   497,   366,   404,
   374,   175,   213,   366,   208,   378,     8,   402,   366,    50,
   575,   177,   366,   366,    51,   178,    30,   119,     9,    26,
    27,    38,   358,    29,    39,     9,   359,   450,   405,   127,
    30,    42,    91,    30,    43,   711,    44,    45,   713,   400,
   129,   -30,   544,    53,   -30,   127,  -198,   545,   546,    26,
    27,    29,   478,   464,   454,   547,    47,   366,   548,   476,
   240,    54,  -276,   549,   574,   695,   103,   697,    47,   128,
    45,   -31,  -276,    30,   -31,   101,    75,  -216,  -216,   550,
   429,   102,    26,    27,    30,    44,    45,  -153,   712,   127,
    47,   124,   499,  -216,   405,  -198,   466,   483,   467,  -216,
   430,   431,   501,  -216,   582,   432,   517,   401,   366,   519,
   520,   126,  -216,    30,   152,    38,    29,   532,   433,   206,
   210,   153,  -216,   405,    38,   208,   652,   404,   402,   128,
    45,  -276,  -276,  -216,   -16,   524,   -16,   531,   692,   154,
    26,    27,    26,    27,   128,    45,  -276,  -276,    26,    27,
   160,   483,  -197,   567,    44,    45,  -198,    26,    27,   573,
   213,   287,  -216,  -216,  -216,   155,  -216,  -216,   163,  -216,
   199,    44,    45,   200,    30,   128,    45,  -198,   252,   579,
    30,  -198,    30,    48,    45,  -198,   156,   157,    26,    27,
   128,    45,   261,   597,   262,    30,    30,   284,   129,   594,
   464,   856,   208,   263,   366,   273,   366,   606,   148,   149,
   150,   151,    59,   275,   617,    60,   208,    29,    61,   601,
   602,   277,   404,   202,   203,   280,  -277,  -277,    95,    96,
   658,   659,   832,   833,    30,   839,   840,   310,    29,   784,
   206,   290,  -277,   324,   327,   331,    29,   270,  -277,   333,
   334,   339,  -277,   665,    62,    63,   340,   342,   656,   357,
   355,  -277,   362,    64,    65,   363,   364,    66,   377,   397,
   380,  -277,   682,   356,   398,   399,    38,    67,    68,    26,
    27,   423,   857,   325,   442,   444,   445,   694,   448,   862,
   452,   459,   699,   782,   787,   461,   786,    29,   821,   470,
   463,   477,    30,   869,   479,    30,   480,   481,   487,   482,
   490,  -277,  -277,  -277,   500,  -277,  -277,   206,  -277,   518,
   521,   167,   530,   534,   536,   134,   366,   168,   311,   366,
   537,   206,   541,   716,   843,   540,   170,   171,   543,   561,
   564,     9,   205,   569,   173,   577,   174,   716,   576,   578,
   580,   617,   213,   595,   583,   603,   584,   581,   599,   608,
   592,   135,   607,   759,   136,   615,    30,   628,   653,   137,
   605,   655,   175,   660,   661,    29,   666,    85,   667,   673,
   675,   176,   177,   679,   676,   680,   178,   689,   617,     9,
   129,   681,   777,   685,   698,  -165,   701,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   119,   148,   149,
   150,   151,    29,   703,   719,   723,   682,   718,   726,   721,
   724,   727,    91,   730,   734,   731,   682,   736,   741,   747,
   749,  -165,   748,   738,  -165,   751,   755,   682,   167,  -165,
   753,   757,   761,   119,   168,   491,   654,   772,   205,   763,
    76,   792,   771,   170,   799,   816,   303,   824,    91,   776,
   779,   173,   764,   174,   790,   791,    75,  -165,  -165,  -165,
  -165,  -165,  -165,  -165,  -165,  -165,  -165,   795,  -165,  -165,
  -165,  -165,   797,    85,   802,   167,    76,   804,   805,   175,
   807,   168,   781,   815,   806,   825,   826,   812,   167,   177,
   170,   831,    75,   178,   168,   291,     9,   492,   173,   834,
   174,   169,   828,   170,   171,   835,   836,   842,   167,   847,
   848,   173,   292,   174,   168,   844,   850,   853,   854,   855,
   858,   169,   860,   170,   171,   859,   175,   861,   864,   863,
   868,   173,   292,   174,   866,   867,   177,   870,   872,   175,
   178,   873,   447,     9,   492,   769,   810,   516,   176,   177,
   183,   845,    59,   178,   428,    60,     9,   337,   285,   175,
   117,   204,   281,   591,   167,   109,   279,   657,   176,   177,
   168,    59,   343,   178,    60,   715,     9,   169,   590,   170,
   171,   785,   214,   286,   172,   817,   708,   173,   742,   174,
   743,   555,   720,   556,    62,    63,   754,   780,    59,   838,
   752,    60,   194,    64,    65,   691,   559,    66,   745,   566,
     0,     0,     0,    62,    63,   175,     0,    67,    68,    26,
    27,     0,    64,    65,   176,   177,    66,     0,     0,   178,
     0,     0,     9,   654,     0,     0,    67,    68,    26,    27,
    62,    63,     0,     0,     0,     0,     0,     0,     0,    64,
    65,     0,     0,    66,     0,     0,     0,   502,     0,     0,
     0,     0,     0,    67,    68,    26,    27,   503,   504,   505,
     0,     0,     0,     0,     0,   506,     0,     0,     0,   507,
     0,     0,     0,     0,     0,     0,     0,   508,   139,   140,
   141,   142,   143,   144,   145,   146,   147,     0,   148,   149,
   150,   151,     0,   509,     0,   510,     0,     0,     0,     0,
     0,     0,     0,     0,   511,   512,     0,     0,     0,   513,
     0,     0,     0,   514,   217,   219,   220,   221,   222,   223,
   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,
   234,   235,   236,   237,   238,   218,   218,   218,   218,   218,
   218,   218,   218,   218,   218,   218,   218,   218,   218,   218,
   218,   218,   218,   218,   218,   218,-32768,-32768,-32768,-32768,
-32768,-32768,   145,   146,   147,     0,   148,   149,   150,   151
};

static const short yycheck[] = {     9,
    45,   107,   107,   157,   107,   127,   166,    31,   311,   599,
   127,     3,   568,   457,     7,    45,   129,   727,    45,   128,
   107,    66,   107,     9,   174,   688,     8,    25,    25,     6,
   621,   256,    42,   751,   477,    45,    66,     6,    14,    54,
    29,   631,    37,    45,   269,   199,     4,   324,   103,    59,
   477,    19,   329,    54,     9,   565,    42,   334,     6,    45,
   166,   338,   339,   781,    66,    75,    16,    26,    25,   732,
     0,    22,   659,    59,     6,   101,   112,   103,    22,   742,
    66,   126,     6,    52,   108,   803,   673,    42,    77,    75,
   600,    62,    63,    64,    65,   255,    48,   112,   108,    62,
    63,    64,    65,    25,    52,   129,   383,    29,   163,   104,
    60,   112,   157,    58,   112,   112,   706,    68,   836,    76,
    52,   839,   108,   833,    68,   127,   570,   157,    52,   572,
   112,   133,   357,   110,   111,   112,   112,   362,   363,   244,
    98,    99,   860,   112,   112,   572,   736,   810,    58,   255,
   255,   103,   255,   112,   199,   157,   100,   434,   203,   749,
    48,   171,    22,   111,   112,   755,   211,   112,   255,   199,
   255,   157,   196,   203,   399,   325,   203,   170,   769,   111,
   112,   211,    22,   176,   155,   171,    11,   111,   112,    99,
    10,    58,   155,   203,   543,    32,    44,   199,   200,    47,
   425,   203,   112,    83,    29,   679,   680,    10,    68,   211,
     3,   436,    19,   199,    17,   112,     9,   203,    55,    26,
    98,    99,   102,   572,    27,   211,    29,   340,    68,   157,
   108,    34,   101,   789,   103,    28,    58,    57,    41,   284,
   349,    20,    45,    50,    47,   112,   471,   112,    73,    28,
   840,    99,   244,   530,   284,   532,   730,   250,    78,    62,
   100,   109,   110,   111,   112,    58,    59,   711,    98,    99,
   112,   199,    75,   758,    77,    48,    98,    99,   108,    99,
   440,    37,   284,   768,   286,   287,    65,    37,   290,    32,
     5,   111,   112,   303,    99,    74,    99,   101,   284,   103,
     8,    98,    99,   108,   607,    20,    99,   104,   111,   112,
    25,    19,    55,    28,   324,    30,   326,   303,    26,   329,
   112,   331,   104,   105,   334,   107,    98,    99,   338,   339,
    73,    39,   104,   108,   440,   440,    58,   440,   324,   349,
   326,    56,   366,   329,   461,   331,    54,    99,   334,   112,
   500,    66,   338,   339,   112,    70,   366,   402,    73,   111,
   112,   101,   100,   349,   104,    73,   104,   377,   477,    58,
   380,   101,   402,   383,   104,   652,    98,    99,   655,    10,
   366,   101,    13,   112,   104,    58,   108,    18,    19,   111,
   112,   377,   104,   386,   380,    26,   108,   383,    29,   401,
   402,    37,    31,    34,   104,   630,    32,   632,   108,    98,
    99,   101,    41,   423,   104,    37,   402,    15,    16,    50,
    15,    37,   111,   112,   434,    98,    99,   105,   653,    58,
   108,   112,   442,    31,   543,   108,   110,   423,   112,    37,
    35,    36,   444,    41,    58,    40,   448,    78,   434,   451,
   452,   105,    50,   463,     7,   101,   442,   103,    53,   461,
   582,    51,    60,   572,   101,   582,   103,   477,    99,    98,
    99,   100,   101,    71,   101,   461,   103,   463,   628,    79,
   111,   112,   111,   112,    98,    99,   100,   101,   111,   112,
    99,   477,    94,   485,    98,    99,    83,   111,   112,   492,
   524,    99,   100,   101,   102,    94,   104,   105,    55,   107,
   101,    98,    99,   105,   524,    98,    99,   104,   104,   521,
   530,   108,   532,    98,    99,   108,   100,   101,   111,   112,
    98,    99,   112,   543,   112,   545,   546,   107,   524,   541,
   533,   844,   659,   112,   530,   112,   532,   549,    90,    91,
    92,    93,    44,   112,   564,    47,   673,   543,    50,   545,
   546,   112,   572,   100,   101,   104,    15,    16,   111,   112,
   100,   101,   100,   101,   584,    23,    24,   104,   564,   739,
   582,   105,    31,   103,    37,   103,   572,   112,    37,   104,
   103,    37,    41,   595,    86,    87,    37,   100,   584,    25,
   112,    50,    25,    95,    96,    14,   104,    99,   101,   104,
    62,    60,   614,   623,   100,    25,   101,   109,   110,   111,
   112,   103,   847,    48,    37,    37,   103,   629,   102,   854,
    50,   104,   634,   739,   739,    99,   739,   623,   792,    71,
    48,   103,   652,   868,    83,   655,    57,   104,   104,    73,
   104,   100,   101,   102,   101,   104,   105,   659,   107,   104,
    37,     5,    48,   101,   100,     7,   652,    11,    12,   655,
   112,   673,    61,   659,   828,   104,    20,    21,    63,    33,
    99,    73,   727,    15,    28,    25,    30,   673,   104,   104,
   104,   701,   716,    64,   100,   112,   101,   104,    99,    32,
   104,    43,    31,   705,    46,    69,   716,    25,    18,    51,
   112,    48,    56,   104,    59,   701,   104,   727,    83,    35,
    42,    65,    66,    42,    55,    42,    70,    29,   738,    73,
   716,   104,   734,   100,   104,     7,    49,    79,    80,    81,
    82,    83,    84,    85,    86,    87,    88,   792,    90,    91,
    92,    93,   738,   103,    80,   112,   758,    71,    25,   100,
   112,    99,   792,    42,     4,   104,   768,    76,   104,   104,
    76,    43,    37,   101,    46,    67,    72,   779,     5,    51,
   104,    69,    41,   828,    11,    12,   106,    31,   833,   104,
   792,    76,   100,    20,    29,    23,    29,   799,   828,   104,
   101,    28,   109,    30,   104,   104,   792,    79,    80,    81,
    82,    83,    84,    85,    86,    87,    88,   104,    90,    91,
    92,    93,   104,   833,   104,     5,   828,   104,   104,    56,
   104,    11,    12,   104,   112,   104,   104,   112,     5,    66,
    20,   104,   828,    70,    11,    12,    73,    74,    28,    25,
    30,    18,    76,    20,    21,    25,   105,    25,     5,    57,
    29,    28,    29,    30,    11,    12,    17,    25,    41,   101,
   104,    18,    67,    20,    21,   104,    56,    34,   104,    25,
    13,    28,    29,    30,   104,   104,    66,   104,     0,    56,
    70,     0,   375,    73,    74,   722,   770,   447,    65,    66,
   107,   830,    44,    70,   359,    47,    73,   275,   203,    56,
    52,   126,   196,   534,     5,    59,   178,   584,    65,    66,
    11,    44,   284,    70,    47,   657,    73,    18,   533,    20,
    21,   739,   129,   206,    25,   779,   643,    28,   691,    30,
   691,   477,   667,   477,    86,    87,   701,   738,    44,   822,
   697,    47,   107,    95,    96,   623,   477,    99,   691,   482,
    -1,    -1,    -1,    86,    87,    56,    -1,   109,   110,   111,
   112,    -1,    95,    96,    65,    66,    99,    -1,    -1,    70,
    -1,    -1,    73,   106,    -1,    -1,   109,   110,   111,   112,
    86,    87,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    95,
    96,    -1,    -1,    99,    -1,    -1,    -1,     8,    -1,    -1,
    -1,    -1,    -1,   109,   110,   111,   112,    18,    19,    20,
    -1,    -1,    -1,    -1,    -1,    26,    -1,    -1,    -1,    30,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    38,    80,    81,
    82,    83,    84,    85,    86,    87,    88,    -1,    90,    91,
    92,    93,    -1,    54,    -1,    56,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    65,    66,    -1,    -1,    -1,    70,
    -1,    -1,    -1,    74,   134,   135,   136,   137,   138,   139,
   140,   141,   142,   143,   144,   145,   146,   147,   148,   149,
   150,   151,   152,   153,   154,   134,   135,   136,   137,   138,
   139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
   149,   150,   151,   152,   153,   154,    80,    81,    82,    83,
    84,    85,    86,    87,    88,    -1,    90,    91,    92,    93
};
#define YYPURE 1

/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX		yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_memcpy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_memcpy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 192 "bison.simple"

/* The user can define YYPARSE_PARAM as the name of an argument to be passed
   into yyparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef YYPARSE_PARAM
#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
#else
#define YYPARSE_PARAM
#define YYPARSE_PARAM_DECL
#endif

int
yyparse(YYPARSE_PARAM)
     YYPARSE_PARAM_DECL
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_memcpy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_memcpy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_memcpy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 1:
#line 399 "parser.yy"
{ YYACCEPT; ;
    break;}
case 2:
#line 402 "parser.yy"
{ eof = true; ;
    break;}
case 3:
#line 403 "parser.yy"
{ eof = false; ;
    break;}
case 4:
#line 407 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 5:
#line 408 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 6:
#line 412 "parser.yy"
{ yyval.tree.Expr = mLiteralRef(yylsp[0], yyvsp[0].text); ;
    break;}
case 7:
#line 413 "parser.yy"
{ yyval.tree.Expr = build_Expr(mSimpleName(yylsp[0], yyvsp[0].text)); ;
    break;}
case 8:
#line 414 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.PhysicalLiteralRef; ;
    break;}
case 9:
#line 415 "parser.yy"
{ yyval.tree.Expr = mAmbgNullExpr(yylsp[0]); ;
    break;}
case 10:
#line 419 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 11:
#line 420 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 12:
#line 425 "parser.yy"
{ yyval.tree.PhysicalLiteralRef = build_PhysicalLiteralRef(yylsp[-1], yyvsp[-1].text, yyvsp[0].text); ;
    break;}
case 13:
#line 429 "parser.yy"
{ yyval.text = NULL; ;
    break;}
case 15:
#line 435 "parser.yy"
{ yyval.tree.PhysicalLiteralRef = build_PhysicalLiteralRef(yylsp[-1], yyvsp[-1].text, yyvsp[0].text); ;
    break;}
case 16:
#line 439 "parser.yy"
{ yyval.tree.IdList = mIdList(yylsp[0], yyvsp[0].text, NULL); ;
    break;}
case 17:
#line 440 "parser.yy"
{ yyval.tree.IdList = mIdList(yylsp[0], yyvsp[0].text, yyvsp[-2].tree.IdList); ;
    break;}
case 26:
#line 465 "parser.yy"
{ add_libs(yyvsp[0].tree.IdList); ;
    break;}
case 27:
#line 466 "parser.yy"
{ use(yyvsp[0].tree.SelNameList); ;
    break;}
case 28:
#line 470 "parser.yy"
{ yyval.tree.IdList = reverse(yyvsp[-1].tree.IdList); ;
    break;}
case 29:
#line 474 "parser.yy"
{ yyval.tree.SelNameList = reverse(yyvsp[-1].tree.SelNameList); ;
    break;}
case 30:
#line 478 "parser.yy"
{ yyval.tree.SelNameList = mSelNameList(yylsp[0], yyvsp[0].tree.SelName, NULL); ;
    break;}
case 31:
#line 479 "parser.yy"
{ yyval.tree.SelNameList = mSelNameList(yylsp[0], yyvsp[0].tree.SelName, yyvsp[-2].tree.SelNameList); ;
    break;}
case 32:
#line 488 "parser.yy"
{
	nEntity e = mEntity(yylsp[-1], yyvsp[-1].text);
	start(e);
	yyval.tree.Block = e;
    ;
    break;}
case 33:
#line 498 "parser.yy"
{
	yyvsp[-7].tree.Block->stats = yyvsp[-3].tree.ConcurrentStatement;
	if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-9].text))
	    error("%s does not match entity name %s", yyvsp[-1].id, yyvsp[-9].text);
	pop_scope(yyvsp[-7].tree.Block);
    ;
    break;}
case 36:
#line 512 "parser.yy"
{
	    if(cur_scope->is(nkComponent))
		nComponent(cur_scope)->first_generic = yyvsp[-1].tree.Interface;
	;
    break;}
case 39:
#line 525 "parser.yy"
{
	    if(cur_scope->is(nkComponent))
		nComponent(cur_scope)->first_port = yyvsp[-1].tree.Interface;
	;
    break;}
case 42:
#line 537 "parser.yy"
{ yyval.tree.ConcurrentStatement = NULL; ;
    break;}
case 43:
#line 538 "parser.yy"
{ yyval.tree.ConcurrentStatement = yyvsp[0].tree.ConcurrentStatement; ;
    break;}
case 44:
#line 542 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 45:
#line 543 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 46:
#line 547 "parser.yy"
{ yyval.id = NULL; ;
    break;}
case 47:
#line 548 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 48:
#line 553 "parser.yy"
{
	nArchitecture a = mArchitecture(yylsp[-3], yyvsp[-3].text);
	if(a->continued = get_entity(yyvsp[-1].text)) {
	    a->first_generic = nComponent(a->continued)->first_generic;
	    a->first_port = nComponent(a->continued)->first_port;
	}
	start(a);
	yyval.tree.Block = a;
    ;
    break;}
case 49:
#line 566 "parser.yy"
{
	yyvsp[-6].tree.Block->stats = yyvsp[-3].tree.ConcurrentStatement;
	if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-10].text))
	    error("%s does not match architecture name %s", yyvsp[-1].id, yyvsp[-10].text);
	pop_scope(yyvsp[-6].tree.Block);
    ;
    break;}
case 52:
#line 578 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 53:
#line 579 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 54:
#line 585 "parser.yy"
{
    	nConfiguration c = mConfiguration(yylsp[-3], yyvsp[-3].text, get_entity(yyvsp[-1].text));
	start(c);
	if(c->entity) {
    	    // XXX - check where this is really usefull
    	    // c->first_generic = c->entity->first_generic;
	    // c->first_port = c->entity->first_port;
	}
    ;
    break;}
case 55:
#line 597 "parser.yy"
{
	if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-9].text))
	    error("%s does not match configuration name %s", yyvsp[-1].id, yyvsp[-9].text);
    	if(cur_du->tree->is(nkConfiguration))
    	    nConfiguration(cur_du->tree)->config = yyvsp[-3].tree.BlockConfig;
	pop_scope(cur_du->tree);
    ;
    break;}
case 58:
#line 610 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 59:
#line 611 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 60:
#line 617 "parser.yy"
{	if(vaul_name_eq(yyvsp[-1].text, "standard"))
	    start(mStandardPackage(yylsp[-1], yyvsp[-1].text));
	else
	    start(mPackage(yylsp[-1], yyvsp[-1].text));
    ;
    break;}
case 61:
#line 624 "parser.yy"
{
	if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-6].text))
	    error("%s does not match package name %s", yyvsp[-1].id, yyvsp[-6].text);
	pop_scope(cur_du->tree);
    ;
    break;}
case 64:
#line 635 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 65:
#line 636 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 66:
#line 642 "parser.yy"
{
	nPackageBody pb = mPackageBody(yylsp[-1], yyvsp[-1].text);
        pb->continued = get_package(yyvsp[-1].text);
	start(pb);
    ;
    break;}
case 67:
#line 649 "parser.yy"
{
	if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-6].text))
	    error("%s does not match package name %s", yyvsp[-1].id, yyvsp[-6].text);
	pop_scope(cur_du->tree);
    ;
    break;}
case 70:
#line 660 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 71:
#line 661 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 78:
#line 675 "parser.yy"
{ use(yyvsp[0].tree.SelNameList); ;
    break;}
case 112:
#line 730 "parser.yy"
{ use(yyvsp[0].tree.SelNameList); ;
    break;}
case 113:
#line 739 "parser.yy"
{
	    add_decl(yyvsp[-1].tree.Subprogram);
	;
    break;}
case 114:
#line 746 "parser.yy"
{
	    for(nInterface i = yyvsp[0].tree.Subprogram->first_formal; i; i = i->next_element) {
		validate_interface(yyvsp[0].tree.Subprogram, i);
		add_decl(yyvsp[0].tree.Subprogram, i, 0, NULL);
	    }
	    yyval.tree.Subprogram = yyvsp[0].tree.Subprogram;
	;
    break;}
case 115:
#line 757 "parser.yy"
{ yyval.tree.Subprogram = mProcedure(yylsp[-1], yyvsp[-1].text, yyvsp[0].tree.Interface); ;
    break;}
case 116:
#line 759 "parser.yy"
{ yyval.tree.Subprogram = mFunction(yylsp[-3], yyvsp[-3].id, yyvsp[-2].tree.Interface, true, get_type(yyvsp[0].tree.Name)); ;
    break;}
case 117:
#line 763 "parser.yy"
{ yyval.tree.Interface = NULL; ;
    break;}
case 119:
#line 769 "parser.yy"
{
	    nSubprogram s = nSubprogram(add_decl(yyvsp[-1].tree.Subprogram));
	    assert(s->is(nkSubprogram));
	    cur_body = mSubprogramBody(yylsp[0], NULL);
	    cur_body->continued = s;
	    nDeclaration prev;
	    for(prev = cur_scope->first_decl; prev; prev = prev->next_decl)
		if(prev->is(nkSubprogramBody)
		&& nSubprogramBody(prev)->continued == s) {
		    error("redefinition of %n", s);
		    info("%: here is the previous definition", prev);
		    break;
		}
	    add_decl(cur_body);
	    push_scope(cur_body);
	 ;
    break;}
case 120:
#line 789 "parser.yy"
{
	    if(yyvsp[-1].id && cur_body->continued
	    && !vaul_name_eq(yyvsp[-1].id, cur_body->continued->id))
		error("%s does not match subprogram designator %s", yyvsp[-1].id,
		 cur_body->continued->id);
	    cur_body->stats = yyvsp[-3].tree.Statement;
	    pop_scope(cur_body);
	 ;
    break;}
case 121:
#line 800 "parser.yy"
{ yyval.id = NULL; ;
    break;}
case 125:
#line 816 "parser.yy"
{
	    for(nInterface i = yyvsp[0].tree.Interface; i; i = i->next_element) {
		validate_port(i);
		add_decl(i);
	    }
	    yyval.tree.Interface = yyvsp[0].tree.Interface;
	;
    break;}
case 126:
#line 827 "parser.yy"
{
	    for(nInterface i = yyvsp[0].tree.Interface; i; i = i->next_element) {
		validate_generic(i);
		add_decl(i);
	    }
	    yyval.tree.Interface = yyvsp[0].tree.Interface;
	;
    break;}
case 127:
#line 838 "parser.yy"
{
	    nInterface i;
	    for(i = yyvsp[-2].tree.Interface; i && i->next_element; i = i->next_element)
		;
	    if(i) {
		i->next_element = yyvsp[-1].tree.Interface;
		yyval.tree.Interface = yyvsp[-2].tree.Interface;
	    } else
		yyval.tree.Interface = yyvsp[-1].tree.Interface;
	 ;
    break;}
case 128:
#line 851 "parser.yy"
{ yyval.tree.Interface = NULL; ;
    break;}
case 129:
#line 853 "parser.yy"
{
	    nInterface i;
	    for(i = yyvsp[-2].tree.Interface; i && i->next_element; i = i->next_element)
		;
	    if(i) {
		i->next_element = yyvsp[0].tree.Interface;
		yyval.tree.Interface = yyvsp[-2].tree.Interface;
	    } else
		yyval.tree.Interface = yyvsp[0].tree.Interface;
	;
    break;}
case 130:
#line 868 "parser.yy"
{	yyval.tree.Interface = NULL;
	overload_resolution(yyvsp[0].tree.Expr, yyvsp[-2].tree.Type);
	for(nIdList idl = yyvsp[-5].tree.IdList; idl; idl = idl->link)
	    yyval.tree.Interface = mInterface(yylsp[-5], idl->id, yyvsp[-2].tree.Type, yyvsp[0].tree.Expr, yyval.tree.Interface, yyvsp[-6].obj_class, yyvsp[-3].mode, yyvsp[-1].boolean);
    ;
    break;}
case 131:
#line 876 "parser.yy"
{ yyval.boolean = false; ;
    break;}
case 132:
#line 877 "parser.yy"
{ yyval.boolean = true; ;
    break;}
case 133:
#line 881 "parser.yy"
{ yyval.mode = Mode_None; ;
    break;}
case 135:
#line 886 "parser.yy"
{ yyval.obj_class = ObjClass_None; ;
    break;}
case 137:
#line 891 "parser.yy"
{ yyval.mode = Mode_In; ;
    break;}
case 138:
#line 892 "parser.yy"
{ yyval.mode = Mode_Out; ;
    break;}
case 139:
#line 893 "parser.yy"
{ yyval.mode = Mode_InOut; ;
    break;}
case 140:
#line 894 "parser.yy"
{ yyval.mode = Mode_Buffer; ;
    break;}
case 141:
#line 895 "parser.yy"
{ yyval.mode = Mode_Linkage; ;
    break;}
case 142:
#line 900 "parser.yy"
{ yyval.tree.GenAssocElem = yyvsp[-2].tree.GenAssocElem; yyvsp[-2].tree.GenAssocElem->next = reverse(yyvsp[-1].tree.GenAssocElem); ;
    break;}
case 143:
#line 905 "parser.yy"
{   
	    yyval.tree.NamedAssocElem = prepare_named_assocs(yyvsp[0].tree.GenAssocElem)? nNamedAssocElem(yyvsp[0].tree.GenAssocElem) : NULL;
	;
    break;}
case 144:
#line 911 "parser.yy"
{ yyval.tree.GenAssocElem = NULL; ;
    break;}
case 145:
#line 913 "parser.yy"
{ yyvsp[0].tree.GenAssocElem->next = yyvsp[-2].tree.GenAssocElem; yyval.tree.GenAssocElem = yyvsp[0].tree.GenAssocElem; ;
    break;}
case 146:
#line 919 "parser.yy"
{
	    yyval.tree.GenAssocElem = reverse(yyvsp[-1].tree.GenAssocElem);
	    if(yyvsp[-2].tree.GenAssocElem) {
		yyvsp[-2].tree.GenAssocElem->next = yyval.tree.GenAssocElem;
		yyval.tree.GenAssocElem = yyvsp[-2].tree.GenAssocElem;
	    }
	;
    break;}
case 147:
#line 929 "parser.yy"
{ yyval.tree.GenAssocElem = NULL; ;
    break;}
case 148:
#line 931 "parser.yy"
{
	    yyval.tree.GenAssocElem = yyvsp[-2].tree.GenAssocElem;
	    if(yyvsp[0].tree.GenAssocElem) {
		yyvsp[0].tree.GenAssocElem->next = yyval.tree.GenAssocElem;
		yyval.tree.GenAssocElem = yyvsp[0].tree.GenAssocElem;
	    }
	;
    break;}
case 149:
#line 942 "parser.yy"
{
	    yyval.tree.GenAssocElem = mNamedAssocElem(yylsp[-1], NULL, yyvsp[-2].tree.Name, validate_Expr(yyvsp[0].tree.Node));
	;
    break;}
case 150:
#line 946 "parser.yy"
{
	    if(yyvsp[0].tree.Node && yyvsp[0].tree.Node->is(nkRange))
		yyval.tree.GenAssocElem = mRangeAssocElem(yylsp[0], NULL, nRange(yyvsp[0].tree.Node));
	    else 
		yyval.tree.GenAssocElem = mNamedAssocElem(yylsp[0], NULL, NULL, validate_Expr(yyvsp[0].tree.Node));
	;
    break;}
case 155:
#line 965 "parser.yy"
{ yyval.tree.Node = mOpenExpr(yylsp[0]); ;
    break;}
case 156:
#line 973 "parser.yy"
{ yyval.tree.Name = mSimpleName(yylsp[0], yyvsp[0].text); ;
    break;}
case 157:
#line 974 "parser.yy"
{ yyval.tree.Name = yyvsp[0].tree.SelName; ;
    break;}
case 158:
#line 979 "parser.yy"
{
	    yyval.tree.Expr = validate_Expr(yyvsp[0].tree.Node);
	;
    break;}
case 159:
#line 985 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 160:
#line 986 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 161:
#line 987 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 162:
#line 988 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Node; ;
    break;}
case 163:
#line 990 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "nand", yyvsp[0].tree.Expr); ;
    break;}
case 164:
#line 992 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "nor", yyvsp[0].tree.Expr); ;
    break;}
case 165:
#line 997 "parser.yy"
{
	    yyval.tree.Expr = validate_Expr(yyvsp[0].tree.Node);
	;
    break;}
case 166:
#line 1004 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "and", yyvsp[0].tree.Expr); ;
    break;}
case 167:
#line 1006 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "and", yyvsp[0].tree.Expr); ;
    break;}
case 168:
#line 1011 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "or", yyvsp[0].tree.Expr); ;
    break;}
case 169:
#line 1013 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "or", yyvsp[0].tree.Expr); ;
    break;}
case 170:
#line 1018 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "xor", yyvsp[0].tree.Expr); ;
    break;}
case 171:
#line 1020 "parser.yy"
{ yyval.tree.Expr = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "xor", yyvsp[0].tree.Expr); ;
    break;}
case 173:
#line 1027 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[0], yyvsp[0].tree.Expr, "+", NULL); ;
    break;}
case 174:
#line 1029 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[0], yyvsp[0].tree.Expr, "-", NULL); ;
    break;}
case 175:
#line 1031 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[0], yyvsp[0].tree.Expr, "abs", NULL); ;
    break;}
case 176:
#line 1033 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[0], yyvsp[0].tree.Expr, "not", NULL); ;
    break;}
case 177:
#line 1035 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "**", yyvsp[0].tree.Expr); ;
    break;}
case 178:
#line 1041 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "mod", yyvsp[0].tree.Expr); ;
    break;}
case 179:
#line 1043 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "rem", yyvsp[0].tree.Expr); ;
    break;}
case 180:
#line 1045 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "&", yyvsp[0].tree.Expr); ;
    break;}
case 181:
#line 1047 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "*", yyvsp[0].tree.Expr); ;
    break;}
case 182:
#line 1049 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "+", yyvsp[0].tree.Expr); ;
    break;}
case 183:
#line 1051 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "-", yyvsp[0].tree.Expr); ;
    break;}
case 184:
#line 1053 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "<=", yyvsp[0].tree.Expr); ;
    break;}
case 185:
#line 1055 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, ">=", yyvsp[0].tree.Expr); ;
    break;}
case 186:
#line 1057 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "<", yyvsp[0].tree.Expr); ;
    break;}
case 187:
#line 1059 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, ">", yyvsp[0].tree.Expr); ;
    break;}
case 188:
#line 1061 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "=", yyvsp[0].tree.Expr); ;
    break;}
case 189:
#line 1063 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "/=", yyvsp[0].tree.Expr); ;
    break;}
case 190:
#line 1065 "parser.yy"
{ yyval.tree.Node = build_bcall(yylsp[-1], yyvsp[-2].tree.Expr, "/", yyvsp[0].tree.Expr); ;
    break;}
case 191:
#line 1069 "parser.yy"
{ yyval.tree.Node = build_Expr_or_Attr(yyvsp[0].tree.Name); ;
    break;}
case 192:
#line 1070 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 193:
#line 1071 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.AmbgAggregate; ;
    break;}
case 194:
#line 1072 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 195:
#line 1073 "parser.yy"
{ yyval.tree.Node = yyvsp[0].tree.Expr; ;
    break;}
case 196:
#line 1074 "parser.yy"
{ yyval.tree.Node = yyvsp[-1].tree.Expr ;
    break;}
case 197:
#line 1079 "parser.yy"
{
	    yyval.tree.Expr = validate_Expr(yyvsp[0].tree.Node);
	;
    break;}
case 200:
#line 1090 "parser.yy"
{ yyval.tree.Name = mOpSymbol(yylsp[0], yyvsp[0].text); ;
    break;}
case 201:
#line 1091 "parser.yy"
{ yyval.tree.Name = yyvsp[0].tree.AttributeName; ;
    break;}
case 203:
#line 1096 "parser.yy"
{ yyval.tree.SelName = mSelName(yylsp[-2], yyvsp[-2].tree.Name, yyvsp[0].id); ;
    break;}
case 204:
#line 1100 "parser.yy"
{ yyval.tree.Name = mSelName(yylsp[-2], yyvsp[-2].tree.Name, yyvsp[0].text); ;
    break;}
case 205:
#line 1101 "parser.yy"
{ yyval.tree.Name = mSimpleName(yylsp[0], yyvsp[0].text); ;
    break;}
case 206:
#line 1105 "parser.yy"
{ yyval.id = yyvsp[0].id; ;
    break;}
case 207:
#line 1106 "parser.yy"
{ yyval.id = yyvsp[0].text; ;
    break;}
case 208:
#line 1107 "parser.yy"
{ yyval.id = "all"; ;
    break;}
case 209:
#line 1111 "parser.yy"
{
	    nName n = yyvsp[-1].tree.Name; // gcc bug?
	    if(n->is(nkAttributeName)) {
		nAttributeName(n)->first_actual =
		    prepare_named_assocs(yyvsp[0].tree.GenAssocElem)? nNamedAssocElem(yyvsp[0].tree.GenAssocElem) : NULL;
		yyval.tree.Name = n;
	    } else {
		if(validate_gen_assocs(yyvsp[0].tree.GenAssocElem))
		    yyval.tree.Name = mIftsName(yylsp[-1], n, yyvsp[0].tree.GenAssocElem);
		else
		    yyval.tree.Name = NULL;
	    }
	;
    break;}
case 210:
#line 1125 "parser.yy"
{
	    nName n = yyvsp[-1].tree.Name; // gcc bug?
	    if(n->is(nkAttributeName)) {
		nAttributeName(n)->first_actual =
		    prepare_named_assocs(yyvsp[0].tree.GenAssocElem)? nNamedAssocElem(yyvsp[0].tree.GenAssocElem) : NULL;
		yyval.tree.Name = n;
	    } else {
		if(validate_gen_assocs(yyvsp[0].tree.GenAssocElem))
		    yyval.tree.Name = mIftsName(yylsp[-1], n, yyvsp[0].tree.GenAssocElem);
		else
		    yyval.tree.Name = NULL;
	    }
	;
    break;}
case 211:
#line 1142 "parser.yy"
{ yyval.tree.AttributeName = mAttributeName(yylsp[-2], yyvsp[-2].tree.Name, yyvsp[0].text, NULL); ;
    break;}
case 212:
#line 1144 "parser.yy"
{ yyval.tree.AttributeName = mAttributeName(yylsp[-2], yyvsp[-2].tree.Name, yyvsp[0].text, NULL); ;
    break;}
case 213:
#line 1146 "parser.yy"
{ yyval.tree.AttributeName = mAttributeName(yylsp[-2], yyvsp[-2].tree.Name, "RANGE", NULL); ;
    break;}
case 214:
#line 1148 "parser.yy"
{ yyval.tree.AttributeName = mAttributeName(yylsp[-2], yyvsp[-2].tree.Name, "RANGE", NULL); ;
    break;}
case 215:
#line 1153 "parser.yy"
{
	    nAttributeName n = yyval.tree.AttributeName = yyvsp[-1].tree.AttributeName;
	    if(n)
		n->first_actual = yyvsp[0].tree.NamedAssocElem;
	;
    break;}
case 216:
#line 1161 "parser.yy"
{ yyval.tree.NamedAssocElem = NULL; ;
    break;}
case 217:
#line 1163 "parser.yy"
{ yyval.tree.NamedAssocElem = mNamedAssocElem(yylsp[-2], NULL, NULL, yyvsp[-1].tree.Expr); ;
    break;}
case 218:
#line 1168 "parser.yy"
{
	    yyval.tree.AmbgAggregate = mAmbgAggregate(yylsp[-1], reverse(yyvsp[-1].tree.ElemAssoc));
	;
    break;}
case 219:
#line 1172 "parser.yy"
{
	    yyval.tree.AmbgAggregate = mAmbgAggregate(yylsp[-4], mElemAssoc(yylsp[-2], NULL, yyvsp[-3].tree.Choice, yyvsp[-1].tree.Expr));
	;
    break;}
case 220:
#line 1179 "parser.yy"
{
	    if(yyvsp[0].tree.ElemAssoc) {
		yyvsp[0].tree.ElemAssoc->next = yyvsp[-2].tree.ElemAssoc;
		yyval.tree.ElemAssoc = yyvsp[0].tree.ElemAssoc;
	    } else
		yyval.tree.ElemAssoc = yyvsp[-2].tree.ElemAssoc;
	;
    break;}
case 221:
#line 1187 "parser.yy"
{
	    if(yyvsp[0].tree.ElemAssoc) {
		yyvsp[0].tree.ElemAssoc->next = yyvsp[-2].tree.ElemAssoc;
		yyval.tree.ElemAssoc = yyvsp[0].tree.ElemAssoc;
	    } else
		yyval.tree.ElemAssoc = yyvsp[-2].tree.ElemAssoc;
	;
    break;}
case 222:
#line 1198 "parser.yy"
{ yyval.tree.Expr = build_QualifiedExpr(yyvsp[-4].tree.Name, yyvsp[-1].tree.Expr); ;
    break;}
case 223:
#line 1200 "parser.yy"
{ yyval.tree.Expr = build_QualifiedExpr(yyvsp[-2].tree.Name, yyvsp[0].tree.AmbgAggregate); ;
    break;}
case 224:
#line 1206 "parser.yy"
{
	    nType t = mAccessType(yylsp[-3], NULL, build_SubType(yyvsp[-2].tree.Name, yyvsp[-1].tree.Name, yyvsp[0].tree.PreIndexConstraint));
	    yyval.tree.Expr = mNewExpr(yylsp[-3], t, NULL);
	;
    break;}
case 225:
#line 1211 "parser.yy"
{
	    nType t = mAccessType(yylsp[-2], NULL, build_SubType(NULL, yyvsp[-1].tree.Name, yyvsp[0].tree.PreIndexConstraint));
	    yyval.tree.Expr = mNewExpr(yylsp[-2], t, NULL);
	;
    break;}
case 226:
#line 1216 "parser.yy"
{
	    nExpr e = yyvsp[0].tree.Expr;
	    overload_resolution(e, nkType);
	    if(e) {
		assert(e->is(nkQualifiedExpr));
		nQualifiedExpr qe = nQualifiedExpr(e);
		yyval.tree.Expr = mNewExpr(yylsp[-1], mAccessType(yylsp[-1], NULL, qe->type),
			      qe->expression);
	    } else
		yyval.tree.Expr = NULL;
	;
    break;}
case 227:
#line 1230 "parser.yy"
{ yyval.tree.PreIndexConstraint = NULL; ;
    break;}
case 228:
#line 1231 "parser.yy"
{ yyval.tree.PreIndexConstraint = build_PreIndexConstraint(yyvsp[0].tree.GenAssocElem); ;
    break;}
case 229:
#line 1240 "parser.yy"
{ yyval.tree.ElemAssoc = mElemAssoc(yylsp[-1], NULL, yyvsp[-2].tree.Choice, yyvsp[0].tree.Expr); ;
    break;}
case 230:
#line 1242 "parser.yy"
{ yyval.tree.ElemAssoc = mElemAssoc(yylsp[0], NULL, NULL, yyvsp[0].tree.Expr); ;
    break;}
case 231:
#line 1247 "parser.yy"
{
	    if(yyvsp[-1].tree.Choice) {
		yyvsp[-1].tree.Choice->next = yyvsp[0].tree.Choice;
		yyval.tree.Choice = yyvsp[-1].tree.Choice;
	    } else
		yyval.tree.Choice = yyvsp[0].tree.Choice;
	;
    break;}
case 232:
#line 1257 "parser.yy"
{ yyval.tree.Choice = NULL; ;
    break;}
case 233:
#line 1259 "parser.yy"
{
	    if(yyvsp[-2].tree.Choice) {
		nChoice c;
		for(c = yyvsp[-2].tree.Choice; c->next; c = c->next)
		    ;
		c->next = yyvsp[0].tree.Choice;
		yyval.tree.Choice = yyvsp[-2].tree.Choice;
	    } else
		yyval.tree.Choice = yyvsp[0].tree.Choice;
	;
    break;}
case 234:
#line 1273 "parser.yy"
{
	    nNode e = yyvsp[0].tree.Node;
	    if(e->is(nkArrayRange))
		yyval.tree.Choice = mRangeChoice(yylsp[0], NULL,
				  mRangeAssocElem(yylsp[0], NULL, nArrayRange(e)));
	    else
		yyval.tree.Choice = mExprChoice(yylsp[0], NULL, validate_Expr(e));
	;
    break;}
case 235:
#line 1282 "parser.yy"
{
	    yyval.tree.Choice = mRangeChoice(yylsp[0], NULL, yyvsp[0].tree.GenAssocElem);
	;
    break;}
case 236:
#line 1286 "parser.yy"
{
	    yyval.tree.Choice = mOthersChoice(yylsp[0], NULL);
	;
    break;}
case 237:
#line 1296 "parser.yy"
{ start_decl(yyvsp[0].text); yyval.id = yyvsp[0].text; ;
    break;}
case 238:
#line 1301 "parser.yy"
{ 
	    nType t = nType(add_decl(cur_scope, yyvsp[-1].tree.Type, yylsp[-2], yyvsp[-2].id));
	    add_predefined_ops(t);
	;
    break;}
case 239:
#line 1308 "parser.yy"
{ yyval.tree.Type = mIncompleteType(0, NULL); ;
    break;}
case 240:
#line 1309 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 241:
#line 1313 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 242:
#line 1314 "parser.yy"
{ yyval.tree.Type = build_SubType_def(yylsp[0], yyvsp[0].tree.Range); ;
    break;}
case 243:
#line 1315 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 244:
#line 1316 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 245:
#line 1317 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 246:
#line 1318 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.RecordType; ;
    break;}
case 247:
#line 1319 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.AccessType; ;
    break;}
case 248:
#line 1320 "parser.yy"
{ yyval.tree.Type = yyvsp[0].tree.Type; ;
    break;}
case 249:
#line 1325 "parser.yy"
{
	    yyval.tree.Type = mEnumType(0, NULL, yyvsp[-1].tree.EnumLiteral);
	    for(nEnumLiteral el = yyvsp[-1].tree.EnumLiteral; el; el = el->next)
		el->type = nEnumType(yyval.tree.Type);
	;
    break;}
case 250:
#line 1334 "parser.yy"
{ yyval.tree.EnumLiteral = nEnumLiteral(add_decl(mEnumLiteral(yylsp[-1], yyvsp[-1].id, NULL, yyvsp[0].tree.EnumLiteral))); ;
    break;}
case 251:
#line 1337 "parser.yy"
{ yyval.tree.EnumLiteral = NULL; ;
    break;}
case 252:
#line 1338 "parser.yy"
{ yyval.tree.EnumLiteral = yyvsp[0].tree.EnumLiteral; ;
    break;}
case 253:
#line 1346 "parser.yy"
{
	    nPhysicalType base = mPhysicalType(0, NULL, yyvsp[-3].tree.PhysicalUnit, NULL);
	    if(yyvsp[-3].tree.PhysicalUnit) {
		yyvsp[-3].tree.PhysicalUnit->next = reverse(yyvsp[-2].tree.PhysicalUnit);
		for(nPhysicalUnit pu = yyvsp[-3].tree.PhysicalUnit; pu; pu = pu->next) {
		    if(pu->value && pu->value->unit
		    && pu->value->unit->type != base)
			error("%:value of unit %n must be from its"
			      " physical type", pu, pu);
		    pu->type = base;
		}
	    }
	    yyval.tree.Type = base->declaring_subtype = build_SubType_def(yylsp[-5], yyvsp[-5].tree.Range, base);
	;
    break;}
case 254:
#line 1363 "parser.yy"
{ yyval.tree.PhysicalUnit = NULL; ;
    break;}
case 255:
#line 1365 "parser.yy"
{
	    if(yyvsp[0].tree.PhysicalUnit) {
		yyvsp[0].tree.PhysicalUnit->next = yyvsp[-1].tree.PhysicalUnit;
		yyval.tree.PhysicalUnit = yyvsp[0].tree.PhysicalUnit;
	    } else
		yyval.tree.PhysicalUnit = yyvsp[-1].tree.PhysicalUnit;
	;
    break;}
case 256:
#line 1376 "parser.yy"
{
	    yyval.tree.PhysicalUnit = nPhysicalUnit(
		    add_decl(mPhysicalUnit(yylsp[-1], yyvsp[-1].text, NULL, NULL, NULL))
		 );
	;
    break;}
case 257:
#line 1385 "parser.yy"
{
	    if(yyvsp[-1].tree.PhysicalLiteralRef && !is_integer_literal(yyvsp[-1].tree.PhysicalLiteralRef->value))
		error("secondary units must be integer multiples");
	    yyval.tree.PhysicalUnit = nPhysicalUnit(
		    add_decl(mPhysicalUnit(yylsp[-3], yyvsp[-3].text, NULL, yyvsp[-1].tree.PhysicalLiteralRef, NULL))
		 );
	;
    break;}
case 258:
#line 1396 "parser.yy"
{
	    yyval.tree.Type = mArrayType(yylsp[-5], NULL, yyvsp[-3].tree.IndexType, yyvsp[0].tree.Type);
	;
    break;}
case 259:
#line 1403 "parser.yy"
{
	    if(yyvsp[-1].tree.IndexType) {
		yyvsp[-1].tree.IndexType->next = yyvsp[0].tree.IndexType;
		yyval.tree.IndexType = yyvsp[-1].tree.IndexType;
	    } else
		yyval.tree.IndexType = yyvsp[0].tree.IndexType;
	;
    break;}
case 260:
#line 1414 "parser.yy"
{
	    yyval.tree.IndexType = NULL;
	;
    break;}
case 261:
#line 1418 "parser.yy"
{
	    if(yyvsp[-1].tree.IndexType) {
		yyvsp[-1].tree.IndexType->next = yyvsp[0].tree.IndexType;
		yyval.tree.IndexType = yyvsp[-1].tree.IndexType;
	    } else
		yyval.tree.IndexType = yyvsp[0].tree.IndexType;
	;
    break;}
case 262:
#line 1429 "parser.yy"
{
	    yyval.tree.IndexType = mIndexType(yylsp[-2], NULL, get_type(yyvsp[-2].tree.Name));
	;
    break;}
case 263:
#line 1436 "parser.yy"
{
	    yyval.tree.Type = build_constrained_array_type(yyvsp[-2].tree.PreIndexConstraint, yyvsp[0].tree.Type);
	;
    break;}
case 264:
#line 1443 "parser.yy"
{
	    yyval.tree.RecordType = mRecordType(yylsp[-4], NULL, concat(yyvsp[-3].tree.RecordElement, yyvsp[-2].tree.RecordElement));
	;
    break;}
case 265:
#line 1450 "parser.yy"
{
	    yyval.tree.RecordElement = NULL;
	;
    break;}
case 266:
#line 1454 "parser.yy"
{
	    yyval.tree.RecordElement = concat(yyvsp[-1].tree.RecordElement, yyvsp[0].tree.RecordElement);
	;
    break;}
case 267:
#line 1461 "parser.yy"
{
	    yyval.tree.RecordElement = NULL;
	    for(nIdList idl = reverse(yyvsp[-3].tree.IdList); idl; idl = idl->link)
		yyval.tree.RecordElement = mRecordElement(idl->lineno, yyval.tree.RecordElement, idl->id, yyvsp[-1].tree.Type);
	    yyval.tree.RecordElement = reverse(yyval.tree.RecordElement);
	;
    break;}
case 268:
#line 1471 "parser.yy"
{
	    if(yyvsp[0].tree.Type && yyvsp[0].tree.Type->is(nkFileType)) {
		error("%:can't access files", yyvsp[0].tree.Type);
		yyvsp[0].tree.Type = NULL;
	    }
	    yyval.tree.AccessType = mAccessType(yylsp[-1], NULL, yyvsp[0].tree.Type);
	;
    break;}
case 269:
#line 1482 "parser.yy"
{
	    nType ct = get_type(yyvsp[0].tree.Name);
	    if(ct)
		info("xxx - unchecked file type: %n", ct);
	    yyval.tree.Type = mFileType(yylsp[-2], NULL, ct);
	;
    break;}
case 270:
#line 1496 "parser.yy"
{
	    if(yyvsp[-1].tree.Type && yyvsp[-1].tree.Type->scope)
		add_decl(mSubType(yylsp[-3], yyvsp[-3].id, yyvsp[-1].tree.Type, NULL, NULL));
	    else
		add_decl(cur_scope, yyvsp[-1].tree.Type, yylsp[-3], yyvsp[-3].id);
	;
    break;}
case 271:
#line 1505 "parser.yy"
{ yyval.tree.Type = build_SubType(NULL, yyvsp[-1].tree.Name, yyvsp[0].tree.PreIndexConstraint); ;
    break;}
case 273:
#line 1510 "parser.yy"
{ yyval.tree.Type = build_SubType(yyvsp[-2].tree.Name, yyvsp[-1].tree.Name, yyvsp[0].tree.Range); ;
    break;}
case 274:
#line 1511 "parser.yy"
{ yyval.tree.Type = build_SubType(NULL, yyvsp[-1].tree.Name, yyvsp[0].tree.Range); ;
    break;}
case 275:
#line 1512 "parser.yy"
{ yyval.tree.Type = build_SubType(yyvsp[-2].tree.Name, yyvsp[-1].tree.Name, yyvsp[0].tree.PreIndexConstraint); ;
    break;}
case 276:
#line 1516 "parser.yy"
{ yyval.tree.PreIndexConstraint = NULL; ;
    break;}
case 277:
#line 1517 "parser.yy"
{ yyval.tree.PreIndexConstraint = build_PreIndexConstraint(yyvsp[0].tree.GenAssocElem); ;
    break;}
case 278:
#line 1521 "parser.yy"
{ yyval.tree.Range = yyvsp[0].tree.Range; ;
    break;}
case 279:
#line 1526 "parser.yy"
{
	    if(yyvsp[-2].tree.GenAssocElem) {
		yyvsp[-2].tree.GenAssocElem->next = reverse(yyvsp[-1].tree.GenAssocElem);
		yyval.tree.PreIndexConstraint = build_PreIndexConstraint(yyvsp[-2].tree.GenAssocElem);
	    } else
		yyval.tree.PreIndexConstraint = build_PreIndexConstraint(yyvsp[-1].tree.GenAssocElem);
	;
    break;}
case 280:
#line 1537 "parser.yy"
{
	    yyval.tree.GenAssocElem = NULL;
	;
    break;}
case 281:
#line 1541 "parser.yy"
{
	    if(yyvsp[0].tree.GenAssocElem) {
		yyvsp[0].tree.GenAssocElem->next = yyvsp[-2].tree.GenAssocElem;
		yyval.tree.GenAssocElem = yyvsp[0].tree.GenAssocElem;
	    } else
		yyval.tree.GenAssocElem = yyvsp[-2].tree.GenAssocElem;
	;
    break;}
case 282:
#line 1552 "parser.yy"
{
	    if(is_discrete_type(yyvsp[0].tree.Type))
		yyval.tree.GenAssocElem = mSubtypeAssocElem(yylsp[0], NULL, yyvsp[0].tree.Type);
	    else {
		if(yyvsp[0].tree.Type)
		    error("%!%n is not a discrete type", lex, int(yylsp[0]), yyvsp[0].tree.Type);
		yyval.tree.GenAssocElem = NULL;
	    }
	;
    break;}
case 283:
#line 1562 "parser.yy"
{
	    yyval.tree.GenAssocElem = mRangeAssocElem(yylsp[0], NULL, yyvsp[0].tree.Range);
	;
    break;}
case 284:
#line 1569 "parser.yy"
{
	    if(is_discrete_type(yyvsp[0].tree.Type))
		yyval.tree.GenAssocElem = mSubtypeAssocElem(yylsp[0], NULL, yyvsp[0].tree.Type);
	    else {
		if(yyvsp[0].tree.Type)
		    error("%!%n is not a discrete type", lex, int(yylsp[0]), yyvsp[0].tree.Type);
		yyval.tree.GenAssocElem = NULL;
	    }
	;
    break;}
case 285:
#line 1579 "parser.yy"
{
	    yyval.tree.GenAssocElem = mRangeAssocElem(yylsp[-2], NULL, mExplicitRange(yylsp[-1], yyvsp[-1].dir, yyvsp[-2].tree.Expr, yyvsp[0].tree.Expr));
	;
    break;}
case 286:
#line 1586 "parser.yy"
{
	    yyval.tree.Range = NULL;
	    if(yyvsp[0].tree.AttributeName) {
		if(!vaul_name_eq(yyvsp[0].tree.AttributeName->attribute, "range"))
		    error("'%s not valid here, only 'RANGE", yyvsp[0].tree.AttributeName->attribute);
		else {
		    // XXX - tidy up
		    vaul_decl_set *set = new vaul_decl_set(this);
		    find_decls(*set, yyvsp[0].tree.AttributeName);

		    if(set->multi_decls()) {
			nKind basic_k = nkInvalid;
			set->iterate(iterate_for_kind, &basic_k);
			assert(basic_k != nkDeclaration);
			nNode rc = build_AttrNode(yyvsp[0].tree.AttributeName, set, basic_k);
			assert(!rc || rc->is(nkRange));
			yyval.tree.Range = nRange(rc);
		    }
		}
	    }
	;
    break;}
case 287:
#line 1608 "parser.yy"
{
	    yyval.tree.Range = mExplicitRange(yylsp[-1], yyvsp[-1].dir, yyvsp[-2].tree.Expr, yyvsp[0].tree.Expr);
	;
    break;}
case 288:
#line 1614 "parser.yy"
{ yyval.dir = DirectionUp; ;
    break;}
case 289:
#line 1615 "parser.yy"
{ yyval.dir = DirectionDown; ;
    break;}
case 290:
#line 1624 "parser.yy"
{
	    if(yyvsp[-1].tree.Expr == NULL && !cur_scope->is(nkPackage))
		error("constants must be initialized");
	    nType t = adapt_object_type(ObjClass_Constant, yyvsp[-2].tree.Type, yyvsp[-1].tree.Expr);
	    overload_resolution(yyvsp[-1].tree.Expr, t);
	    for(nIdList idl = yyvsp[-4].tree.IdList; idl; idl = idl->link)
		add_decl(mConstant(yylsp[-4], idl->id, t, yyvsp[-1].tree.Expr));
	;
    break;}
case 291:
#line 1638 "parser.yy"
{
	    nType t = adapt_object_type(ObjClass_Signal, yyvsp[-3].tree.Type, yyvsp[-1].tree.Expr);
	    overload_resolution(yyvsp[-1].tree.Expr, t);
	    for(nIdList idl = yyvsp[-5].tree.IdList; idl; idl = idl->link)
		add_decl(mSignal(yylsp[-5], idl->id, t, yyvsp[-1].tree.Expr, yyvsp[-2].signal_kind));
	;
    break;}
case 292:
#line 1647 "parser.yy"
{ yyval.signal_kind = SigKind_None; ;
    break;}
case 294:
#line 1653 "parser.yy"
{
	    nType t = adapt_object_type(ObjClass_Variable, yyvsp[-2].tree.Type, yyvsp[-1].tree.Expr);
	    overload_resolution(yyvsp[-1].tree.Expr, t);
	    for(nIdList idl = yyvsp[-4].tree.IdList; idl; idl = idl->link)
		add_decl(mVariable(yylsp[-4], idl->id, t, yyvsp[-1].tree.Expr, false));
	;
    break;}
case 295:
#line 1662 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 296:
#line 1663 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.Expr; ;
    break;}
case 297:
#line 1667 "parser.yy"
{ yyval.obj_class = ObjClass_Constant; ;
    break;}
case 298:
#line 1668 "parser.yy"
{ yyval.obj_class = ObjClass_Signal; ;
    break;}
case 299:
#line 1669 "parser.yy"
{ yyval.obj_class = ObjClass_Variable; ;
    break;}
case 300:
#line 1670 "parser.yy"
{ yyval.obj_class = ObjClass_File; ;
    break;}
case 301:
#line 1674 "parser.yy"
{ yyval.signal_kind = SigKind_Bus; ;
    break;}
case 302:
#line 1675 "parser.yy"
{ yyval.signal_kind = SigKind_Register; ;
    break;}
case 303:
#line 1680 "parser.yy"
{
	    add_Alias(yylsp[-6], yyvsp[-5].text, yyvsp[-3].tree.Type, yyvsp[-1].tree.Name);
	;
    break;}
case 304:
#line 1688 "parser.yy"
{
	    add_File(yylsp[-6], yyvsp[-5].text, yyvsp[-3].tree.Type, yyvsp[-1].tree.Expr, yyvsp[-2].tree.Expr);
	;
    break;}
case 305:
#line 1695 "parser.yy"
{
	    yyval.tree.Expr = NULL; 
	;
    break;}
case 306:
#line 1699 "parser.yy"
{
	    nExpr e = yyvsp[0].tree.Expr;
	    overload_resolution(e, std->predef_FILE_OPEN_KIND);
	    yyval.tree.Expr = e;
	;
    break;}
case 307:
#line 1708 "parser.yy"
{
	    yyval.tree.Expr = NULL;
	;
    break;}
case 308:
#line 1712 "parser.yy"
{
	    nExpr e = yyvsp[0].tree.Expr;
	    overload_resolution(e, std->predef_STRING);
	    yyval.tree.Expr = e;
	;
    break;}
case 309:
#line 1721 "parser.yy"
{
	    info("XXX - no disconnection specifications");
	;
    break;}
case 310:
#line 1727 "parser.yy"
{ ;
    break;}
case 311:
#line 1728 "parser.yy"
{ ;
    break;}
case 312:
#line 1729 "parser.yy"
{ ;
    break;}
case 315:
#line 1743 "parser.yy"
{
	    nType t = get_type(yyvsp[-1].tree.Name);
	    if(t) {
		nType bt = t->get_base();
		if(bt && bt->is(nkAccessType))
		    error("%!attributes can't have access types",
			     lex, int(yylsp[-4]));
		else if(bt && bt->is(nkFileType))
		    error("%!attributes can't have file types",
			     lex, int(yylsp[-4]));
		else
		    add_decl(mAttribute(yylsp[-4], yyvsp[-3].text, t));
	    }
	;
    break;}
case 316:
#line 1761 "parser.yy"
{
	    bind_attrspec(mAttributeSpec(yylsp[-6], yyvsp[-5].text, yyvsp[-3].tree.EntitySpec, yyvsp[-1].tree.Expr));
	;
    break;}
case 317:
#line 1768 "parser.yy"
{
	    yyval.tree.EntitySpec = mEntitySpec(yylsp[-2], yyvsp[-2].tree.EntityNameList, yyvsp[0].kind);
	;
    break;}
case 318:
#line 1775 "parser.yy"
{
	    yyval.tree.EntityNameList = mEntityNameList_Ids(yylsp[-1], mIdList(yylsp[-1], yyvsp[-1].id, reverse(yyvsp[0].tree.IdList)));
	;
    break;}
case 319:
#line 1779 "parser.yy"
{
	    yyval.tree.EntityNameList = mEntityNameList_OTHERS(yylsp[0]);
	;
    break;}
case 320:
#line 1783 "parser.yy"
{
	    yyval.tree.EntityNameList = mEntityNameList_ALL(yylsp[0]);
	;
    break;}
case 321:
#line 1789 "parser.yy"
{ yyval.tree.IdList = NULL; ;
    break;}
case 322:
#line 1791 "parser.yy"
{
	    yyval.tree.IdList = mIdList(yylsp[0], yyvsp[0].id, yyvsp[-2].tree.IdList);
	;
    break;}
case 323:
#line 1797 "parser.yy"
{ yyval.kind = nkEntity; ;
    break;}
case 324:
#line 1798 "parser.yy"
{ yyval.kind = nkArchitecture; ;
    break;}
case 325:
#line 1799 "parser.yy"
{ yyval.kind = nkPackage; ;
    break;}
case 326:
#line 1800 "parser.yy"
{ yyval.kind = nkConfiguration; ;
    break;}
case 327:
#line 1801 "parser.yy"
{ yyval.kind = nkComponent; ;
    break;}
case 328:
#line 1802 "parser.yy"
{ yyval.kind = nkLabel; ;
    break;}
case 329:
#line 1803 "parser.yy"
{ yyval.kind = nkType; ;
    break;}
case 330:
#line 1804 "parser.yy"
{ yyval.kind = nkSubType; ;
    break;}
case 331:
#line 1805 "parser.yy"
{ yyval.kind = nkProcedure; ;
    break;}
case 332:
#line 1806 "parser.yy"
{ yyval.kind = nkFunction; ;
    break;}
case 333:
#line 1807 "parser.yy"
{ yyval.kind = nkSignal; ;
    break;}
case 334:
#line 1808 "parser.yy"
{ yyval.kind = nkVariable; ;
    break;}
case 335:
#line 1809 "parser.yy"
{ yyval.kind = nkConstant; ;
    break;}
case 336:
#line 1817 "parser.yy"
{ yyval.tree.IterationScheme = NULL; /* XXX */ ;
    break;}
case 337:
#line 1818 "parser.yy"
{ yyval.tree.IterationScheme = yyvsp[0].tree.IterationScheme; ;
    break;}
case 338:
#line 1822 "parser.yy"
{ yyval.tree.IterationScheme = yyvsp[0].tree.IterationScheme; ;
    break;}
case 339:
#line 1823 "parser.yy"
{ yyval.tree.IterationScheme = yyvsp[0].tree.IterationScheme; ;
    break;}
case 340:
#line 1828 "parser.yy"
{
	    info("XXX - no if schemes");
	;
    break;}
case 341:
#line 1835 "parser.yy"
{ yyval.tree.IterationScheme = mPreForScheme(yylsp[-3], yyvsp[-2].text, build_PreIndexConstraint(yyvsp[0].tree.GenAssocElem)); ;
    break;}
case 342:
#line 1839 "parser.yy"
{ yyval.tree.IterationScheme = mWhileScheme(yylsp[-1], yyvsp[0].tree.Expr); ;
    break;}
case 343:
#line 1847 "parser.yy"
{ yyval.tree.ConcurrentStatement = reverse(yyvsp[0].tree.ConcurrentStatement); ;
    break;}
case 344:
#line 1851 "parser.yy"
{ yyval.tree.ConcurrentStatement = NULL; ;
    break;}
case 345:
#line 1853 "parser.yy"
{
	    if(yyvsp[0].tree.ConcurrentStatement) {
		yyvsp[0].tree.ConcurrentStatement->next_stat = yyvsp[-1].tree.ConcurrentStatement;
		yyval.tree.ConcurrentStatement = yyvsp[0].tree.ConcurrentStatement;
	    } else
		yyval.tree.ConcurrentStatement = yyvsp[-1].tree.ConcurrentStatement;
	;
    break;}
case 351:
#line 1869 "parser.yy"
{
	    info("XXX - no generate statements");
	    yyval.tree.ConcurrentStatement = mConcurrentStatement(yylsp[0], NULL);
	;
    break;}
case 353:
#line 1878 "parser.yy"
{
	    nBlockStat b = mBlockStat(yylsp[-3], yyvsp[-4].text);
	    add_decl(b);
	    push_scope(b);
	    if(yyvsp[-1].tree.Expr)
		add_decl(mGuardSignal(yylsp[-1], "GUARD", std->predef_BOOLEAN, yyvsp[-1].tree.Expr,
				      SigKind_None));
	    yyval.tree.BlockStat = b;
	;
    break;}
case 354:
#line 1893 "parser.yy"
{
	    nBlockStat b = yyvsp[-9].tree.BlockStat;
	    b->stats = yyvsp[-4].tree.ConcurrentStatement;
	    b->binding = build_BindingIndic(b, yyvsp[-8].tree.NamedAssocElem, yyvsp[-7].tree.NamedAssocElem);
	    if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-14].text))
		error("'%s' does not match block label '%s'", yyvsp[-1].id, yyvsp[-14].text);
	    pop_scope(b);
	    yyval.tree.ConcurrentStatement = b;
	;
    break;}
case 357:
#line 1910 "parser.yy"
{ yyval.tree.NamedAssocElem = NULL; ;
    break;}
case 358:
#line 1911 "parser.yy"
{ yyval.tree.NamedAssocElem = yyvsp[0].tree.NamedAssocElem; ;
    break;}
case 359:
#line 1915 "parser.yy"
{ yyval.tree.NamedAssocElem = NULL; ;
    break;}
case 360:
#line 1916 "parser.yy"
{ yyval.tree.NamedAssocElem = yyvsp[0].tree.NamedAssocElem; ;
    break;}
case 361:
#line 1920 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 362:
#line 1921 "parser.yy"
{ yyval.tree.Expr = yyvsp[-1].tree.Expr; ;
    break;}
case 363:
#line 1929 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = mComponentInst(yylsp[-3], yyvsp[-5].text, build_BindingIndic(yyvsp[-3].tree.Component, yyvsp[-2].tree.NamedAssocElem, yyvsp[-1].tree.NamedAssocElem));
	    add_decl(yyval.tree.ConcurrentStatement);
	;
    break;}
case 364:
#line 1940 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = mComponentInst(yylsp[-5], yyvsp[-7].text, build_BindingIndic(yyvsp[-5].tree.Component, yyvsp[-2].tree.NamedAssocElem, yyvsp[-1].tree.NamedAssocElem));
	    add_decl(yyval.tree.ConcurrentStatement);
	;
    break;}
case 365:
#line 1948 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = mComponentInst(yylsp[-4], yyvsp[-6].text, build_BindingIndic(yyvsp[-4].tree.Component, NULL, yyvsp[-1].tree.NamedAssocElem));
	    add_decl(yyval.tree.ConcurrentStatement);
	;
    break;}
case 366:
#line 1960 "parser.yy"
{
	    yyval.tree.Component = nComponent(find_single_decl(yyvsp[0].tree.Name, nkComponent, "component"));
	;
    break;}
case 368:
#line 1967 "parser.yy"
{ yyval.tree.NamedAssocElem = NULL; ;
    break;}
case 370:
#line 1972 "parser.yy"
{ yyval.tree.NamedAssocElem = yyvsp[0].tree.NamedAssocElem; ;
    break;}
case 371:
#line 1976 "parser.yy"
{ yyval.tree.NamedAssocElem = NULL; ;
    break;}
case 373:
#line 1981 "parser.yy"
{ yyval.tree.NamedAssocElem = yyvsp[0].tree.NamedAssocElem; ;
    break;}
case 374:
#line 1986 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_conc_AssertStat(yylsp[-2], yyvsp[-2].text, nAssertStat(yyvsp[0].tree.Statement));
	;
    break;}
case 375:
#line 1990 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_conc_AssertStat(yylsp[0], NULL, nAssertStat(yyvsp[0].tree.Statement));
	;
    break;}
case 376:
#line 1999 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_conc_ProcedureCall(yylsp[-2], yyvsp[-2].text, yyvsp[0].tree.ProcedureCallStat);
	;
    break;}
case 377:
#line 2003 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_conc_ProcedureCall(yylsp[0], NULL, yyvsp[0].tree.ProcedureCallStat);
	;
    break;}
case 378:
#line 2009 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_condal_Process(yyvsp[-2].text, yyvsp[0].tree.CondalSignalAssign);
	;
    break;}
case 379:
#line 2014 "parser.yy"
{
	    yyval.tree.ConcurrentStatement = build_condal_Process(NULL, yyvsp[0].tree.CondalSignalAssign);
	;
    break;}
case 380:
#line 2019 "parser.yy"
{
	    info("XXX - no selected signal assignment");
	    yyval.tree.ConcurrentStatement = mConcurrentStatement(yylsp[-2], NULL);
	;
    break;}
case 381:
#line 2025 "parser.yy"
{
	    info("XXX - no selected signal assignment");
	    yyval.tree.ConcurrentStatement = mConcurrentStatement(yylsp[0], NULL);
	;
    break;}
case 382:
#line 2033 "parser.yy"
{
	    yyval.tree.CondalSignalAssign = mCondalSignalAssign(yylsp[-3], yyvsp[-4].tree.Expr, false, yyvsp[-1].tree.CondalWaveform);
	;
    break;}
case 383:
#line 2040 "parser.yy"
{
    	    nCondalWaveform w = mCondalWaveform(yylsp[0], yyvsp[0].tree.WaveformElement, NULL);
    	    if(yyval.tree.CondalWaveform = yyvsp[-1].tree.CondalWaveform) {
            	while(yyvsp[-1].tree.CondalWaveform->else_wave)
    	    	    yyvsp[-1].tree.CondalWaveform = yyvsp[-1].tree.CondalWaveform->else_wave;
    	    	yyvsp[-1].tree.CondalWaveform->else_wave = w;
    	    } else
    	    	yyval.tree.CondalWaveform = w;
    	;
    break;}
case 384:
#line 2052 "parser.yy"
{ yyval.tree.CondalWaveform = NULL; ;
    break;}
case 385:
#line 2054 "parser.yy"
{
    	    nCondalWaveform w = mCondalWaveform(yylsp[-3], yyvsp[-3].tree.WaveformElement, yyvsp[-1].tree.Expr);
    	    if(yyval.tree.CondalWaveform = yyvsp[-4].tree.CondalWaveform) {
            	while(yyvsp[-4].tree.CondalWaveform->else_wave)
    	    	    yyvsp[-4].tree.CondalWaveform = yyvsp[-4].tree.CondalWaveform->else_wave;
    	    	yyvsp[-4].tree.CondalWaveform->else_wave = w;
    	    } else
    	    	yyval.tree.CondalWaveform = w;
    	;
    break;}
case 386:
#line 2067 "parser.yy"
{
	    yyvsp[0].tree.WaveformElement = reverse(yyvsp[0].tree.WaveformElement);
	    if(yyvsp[-1].tree.WaveformElement) {
		yyvsp[-1].tree.WaveformElement->next = yyvsp[0].tree.WaveformElement;
		yyval.tree.WaveformElement = yyvsp[-1].tree.WaveformElement;
	    } else
		yyval.tree.WaveformElement = yyvsp[0].tree.WaveformElement;
	;
    break;}
case 387:
#line 2078 "parser.yy"
{ yyval.tree.WaveformElement = NULL; ;
    break;}
case 388:
#line 2080 "parser.yy"
{
	    if(yyvsp[0].tree.WaveformElement) {
		yyvsp[0].tree.WaveformElement->next = yyvsp[-2].tree.WaveformElement;
		yyval.tree.WaveformElement = yyvsp[0].tree.WaveformElement;
	    } else
		yyval.tree.WaveformElement = yyvsp[-2].tree.WaveformElement;
	;
    break;}
case 389:
#line 2091 "parser.yy"
{
	    yyval.tree.WaveformElement = mWaveformElement(yyvsp[-1].tree.Expr, yyvsp[0].tree.Expr, NULL);
	;
    break;}
case 390:
#line 2097 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 391:
#line 2098 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.Expr; overload_resolution(yyval.tree.Expr, std->predef_TIME); ;
    break;}
case 392:
#line 2102 "parser.yy"
{ yyval.tree.Expr = build_Expr(yyvsp[0].tree.Name); ;
    break;}
case 393:
#line 2103 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.AmbgAggregate; ;
    break;}
case 396:
#line 2112 "parser.yy"
{ info("XXX - no transport"); ;
    break;}
case 398:
#line 2117 "parser.yy"
{ info("XXX - not guarded"); ;
    break;}
case 403:
#line 2136 "parser.yy"
{ ;
    break;}
case 405:
#line 2141 "parser.yy"
{ ;
    break;}
case 406:
#line 2146 "parser.yy"
{
	    nProcess p = mProcess(yylsp[-2], yyvsp[-3].id, yyvsp[-1].tree.SignalList, NULL);
	    add_decl(p);
	    push_scope(p);
	    yyval.tree.Process = p;
	;
    break;}
case 407:
#line 2156 "parser.yy"
{
	    yyvsp[-7].tree.Process->stats = yyvsp[-4].tree.Statement;
	    if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-11].id)) {
		if(yyvsp[-11].id)
		    error("'%s' does not match process label '%s'", yyvsp[-1].id, yyvsp[-11].id);
		else
		    error("process has no label");
	    }
	    yyval.tree.ConcurrentStatement = yyvsp[-7].tree.Process;
	    pop_scope(yyval.tree.ConcurrentStatement);
	;
    break;}
case 408:
#line 2170 "parser.yy"
{ yyval.id = NULL; ;
    break;}
case 409:
#line 2171 "parser.yy"
{ yyval.id = yyvsp[-1].text; ;
    break;}
case 414:
#line 2185 "parser.yy"
{ yyval.tree.SignalList = NULL; ;
    break;}
case 415:
#line 2186 "parser.yy"
{ yyval.tree.SignalList = yyvsp[-1].tree.SignalList; ;
    break;}
case 416:
#line 2191 "parser.yy"
{
	    yyvsp[-1].tree.SignalList->next = reverse(yyvsp[0].tree.SignalList);
	    yyval.tree.SignalList = yyvsp[-1].tree.SignalList;
	;
    break;}
case 417:
#line 2198 "parser.yy"
{ yyval.tree.SignalList = NULL; ;
    break;}
case 418:
#line 2200 "parser.yy"
{
	    yyvsp[0].tree.SignalList->next = yyvsp[-2].tree.SignalList;
	    yyval.tree.SignalList = yyvsp[0].tree.SignalList;
	;
    break;}
case 419:
#line 2208 "parser.yy"
{
	    nExpr e = build_Expr(yyvsp[0].tree.Name);
	    overload_resolution(e, nkType);
	    if(e && (!e->is(nkObjectRef) || !nObjectRef(e)->is_signal())) {
		error("%:%n is not a signal", yyvsp[0].tree.Name, yyvsp[0].tree.Name);
		e = NULL;
	    }
	    yyval.tree.SignalList = mSignalList(nObjectRef(e), NULL);
	;
    break;}
case 420:
#line 2224 "parser.yy"
{ yyval.tree.Statement = reverse(yyvsp[0].tree.Statement); ;
    break;}
case 421:
#line 2228 "parser.yy"
{ yyval.tree.Statement = NULL; ;
    break;}
case 422:
#line 2230 "parser.yy"
{
	    if(yyvsp[0].tree.Statement) {
		yyvsp[0].tree.Statement->next = yyvsp[-1].tree.Statement;
		yyval.tree.Statement = yyvsp[0].tree.Statement;
	    } else
		yyval.tree.Statement = yyvsp[-1].tree.Statement;
	;
    break;}
case 423:
#line 2240 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 424:
#line 2241 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 425:
#line 2242 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 426:
#line 2243 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 427:
#line 2244 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 428:
#line 2245 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 429:
#line 2246 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 430:
#line 2247 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.ProcedureCallStat; ;
    break;}
case 431:
#line 2248 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 432:
#line 2249 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 433:
#line 2250 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 434:
#line 2251 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 435:
#line 2257 "parser.yy"
{
	    yyval.tree.Statement = mAssertStat(yylsp[-4], yyvsp[-3].tree.Expr, yyvsp[-2].tree.Expr, yyvsp[-1].tree.Expr);
	;
    break;}
case 436:
#line 2264 "parser.yy"
{
	    yyval.tree.Expr = NULL;
	;
    break;}
case 437:
#line 2268 "parser.yy"
{
	    yyval.tree.Expr = yyvsp[0].tree.Expr;
	    overload_resolution(yyval.tree.Expr, std->predef_SEVERITY_LEVEL);
	;
    break;}
case 438:
#line 2276 "parser.yy"
{
	    yyval.tree.Expr = NULL;
	;
    break;}
case 439:
#line 2280 "parser.yy"
{
	    yyval.tree.Expr = yyvsp[0].tree.Expr;
	    overload_resolution(yyval.tree.Expr, std->predef_STRING);
	;
    break;}
case 440:
#line 2291 "parser.yy"
{
	    nCaseAlternative ca = reverse(yyvsp[-3].tree.CaseAlternative);
	    if(yyvsp[-4].tree.CaseAlternative) {
		yyvsp[-4].tree.CaseAlternative->next = ca;
		ca = yyvsp[-4].tree.CaseAlternative;
	    }
	    yyval.tree.Statement = build_CaseStat(yylsp[-7], yyvsp[-6].tree.Expr, ca);
	;
    break;}
case 441:
#line 2303 "parser.yy"
{
	    yyval.tree.CaseAlternative = mCaseAlternative(yylsp[-3], NULL, yyvsp[-2].tree.Choice, yyvsp[0].tree.Statement);
	;
    break;}
case 442:
#line 2310 "parser.yy"
{
	    yyval.tree.CaseAlternative = NULL;
	;
    break;}
case 443:
#line 2314 "parser.yy"
{
	    if(yyvsp[0].tree.CaseAlternative) {
		yyvsp[0].tree.CaseAlternative->next = yyvsp[-1].tree.CaseAlternative;
		yyval.tree.CaseAlternative = yyvsp[0].tree.CaseAlternative;
	    } else
		yyval.tree.CaseAlternative = yyvsp[-1].tree.CaseAlternative;
	;
    break;}
case 444:
#line 2326 "parser.yy"
{
	    yyval.tree.Statement = mIfStat(yylsp[-8], yyvsp[-7].tree.Expr, yyvsp[-5].tree.Statement, yyvsp[-4].tree.Statement);
	    if(yyvsp[-3].tree.Statement) {
		nStatement *s;
		for(s = &(nIfStat(yyval.tree.Statement)->else_stats); *s && (*s)->is(nkIfStat);
		    s = &(nIfStat(*s)->else_stats))
		    ;
		assert(*s == NULL);
		*s = yyvsp[-3].tree.Statement;
	    }
	;
    break;}
case 445:
#line 2340 "parser.yy"
{ yyval.tree.Statement = NULL; ;
    break;}
case 446:
#line 2341 "parser.yy"
{ yyval.tree.Statement = yyvsp[0].tree.Statement; ;
    break;}
case 447:
#line 2345 "parser.yy"
{ yyval.tree.Statement = NULL; ;
    break;}
case 448:
#line 2347 "parser.yy"
{
	    yyval.tree.Statement = mIfStat(yylsp[-3], yyvsp[-2].tree.Expr, yyvsp[0].tree.Statement, NULL);
	    if(yyvsp[-4].tree.Statement) {
		nStatement *s;
		for(s = &(nIfStat(yyvsp[-4].tree.Statement)->else_stats); *s && (*s)->is(nkIfStat);
		    s = &(nIfStat(*s)->else_stats))
		    ;
		assert(*s == NULL);
		*s = yyval.tree.Statement;
		yyval.tree.Statement = yyvsp[-4].tree.Statement;
	    }
	;
    break;}
case 449:
#line 2362 "parser.yy"
{ overload_resolution(yyvsp[0].tree.Expr, std->predef_BOOLEAN); yyval.tree.Expr = yyvsp[0].tree.Expr; ;
    break;}
case 450:
#line 2367 "parser.yy"
{ 
	    nLoopStat l = push_loop(yylsp[0], yyvsp[-2].tree.Label, yyvsp[-1].tree.IterationScheme);
	;
    break;}
case 451:
#line 2372 "parser.yy"
{
	    yyval.tree.Statement = pop_loop(yyvsp[-4].tree.Statement, yyvsp[-1].id);
	;
    break;}
case 452:
#line 2378 "parser.yy"
{ yyval.tree.IterationScheme = NULL; ;
    break;}
case 453:
#line 2379 "parser.yy"
{ yyval.tree.IterationScheme = yyvsp[0].tree.IterationScheme; ;
    break;}
case 454:
#line 2383 "parser.yy"
{ yyval.tree.Label = NULL; ;
    break;}
case 455:
#line 2384 "parser.yy"
{ yyval.tree.Label = nLabel(add_decl(mLabel(yylsp[-1], yyvsp[-1].text, NULL))); ;
    break;}
case 456:
#line 2389 "parser.yy"
{   
	    yyval.tree.Statement = build_LoopControlStat(yylsp[-3], nkNextStat, yyvsp[-2].id, yyvsp[-1].tree.Expr);
	;
    break;}
case 457:
#line 2396 "parser.yy"
{   
	    yyval.tree.Statement = build_LoopControlStat(yylsp[-3], nkExitStat, yyvsp[-2].id, yyvsp[-1].tree.Expr);
	;
    break;}
case 458:
#line 2402 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 459:
#line 2403 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.Expr; ;
    break;}
case 460:
#line 2407 "parser.yy"
{ yyval.tree.Statement = mNullStat(yylsp[-1]); ;
    break;}
case 461:
#line 2412 "parser.yy"
{
	    nExpr e = build_Expr(yyvsp[-1].tree.Name);
	    overload_resolution(e, NULL, nkType, true);
	    if(e && e->is(nkProcedureCall))
		yyval.tree.ProcedureCallStat = mProcedureCallStat(yylsp[-1], nProcedureCall(e)->proc,
					nProcedureCall(e)->first_actual);
	    else {
		if(e)
		    error("%:%n is not a procedure call", yyvsp[-1].tree.Name, yyvsp[-1].tree.Name);
		yyval.tree.ProcedureCallStat = NULL;
	    }
	;
    break;}
case 462:
#line 2428 "parser.yy"
{
	    if(cur_body == NULL || cur_body->continued == NULL || yyvsp[-1].tree.Expr == NULL)
		yyval.tree.Statement = NULL;
	    else if(cur_body->continued->is(nkFunction)) {
		if(yyvsp[-1].tree.Expr->is(nkOpenExpr)) {
		    error("return without a value");
		    yyval.tree.Statement = NULL;
		} else {
		    overload_resolution(yyvsp[-1].tree.Expr,
		     nFunction(cur_body->continued)->return_type);
		    yyval.tree.Statement = mReturnStat(yylsp[-2], yyvsp[-1].tree.Expr);
		}
	    } else if(cur_body->continued->is(nkProcedure)) {
		if(!yyvsp[-1].tree.Expr->is(nkOpenExpr)) {
		    error("return with a value");
		    yyval.tree.Statement = NULL;
		} else
		    yyval.tree.Statement = mReturnStat(yylsp[-2], NULL);
	    } else {
		error("can only return from subprograms");
		yyval.tree.Statement = NULL;
	    }
	;
    break;}
case 463:
#line 2454 "parser.yy"
{ yyval.tree.Expr = mOpenExpr(); ;
    break;}
case 465:
#line 2460 "parser.yy"
{
	    yyval.tree.Statement = build_SignalAssignment(yylsp[-3], yyvsp[-4].tree.Expr, yyvsp[-2].boolean, yyvsp[-1].tree.WaveformElement);
	;
    break;}
case 466:
#line 2466 "parser.yy"
{ yyval.boolean = false; ;
    break;}
case 467:
#line 2467 "parser.yy"
{ yyval.boolean = true; ;
    break;}
case 468:
#line 2472 "parser.yy"
{
	    yyval.tree.Statement = build_VarAssignment(yylsp[-2], yyvsp[-3].tree.Expr, yyvsp[-1].tree.Expr);
	;
    break;}
case 469:
#line 2479 "parser.yy"
{
	    yyval.tree.Statement = mWaitStat(yylsp[-4], yyvsp[-3].tree.SignalList, yyvsp[-2].tree.Expr, yyvsp[-1].tree.Expr);
	;
    break;}
case 470:
#line 2485 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 471:
#line 2486 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.Expr; overload_resolution(yyval.tree.Expr, std->predef_TIME); ;
    break;}
case 472:
#line 2490 "parser.yy"
{ yyval.tree.Expr = NULL; ;
    break;}
case 473:
#line 2491 "parser.yy"
{ yyval.tree.Expr = yyvsp[0].tree.Expr; ;
    break;}
case 474:
#line 2495 "parser.yy"
{ yyval.tree.SignalList = NULL; ;
    break;}
case 475:
#line 2496 "parser.yy"
{ yyval.tree.SignalList = yyvsp[0].tree.SignalList; ;
    break;}
case 476:
#line 2505 "parser.yy"
{
	    nComponent c = mComponent(yylsp[-2], yyvsp[-1].text);
	    add_decl(c);
	    push_scope(c);
	    yyval.tree.Component = c;
	;
    break;}
case 477:
#line 2514 "parser.yy"
{
	    if(yyvsp[-1].id && !vaul_name_eq(yyvsp[-1].id, yyvsp[-8].text))
		error("'%s' does not match component name '%s'", yyvsp[-1].id, yyvsp[-8].text);
	    pop_scope(yyvsp[-6].tree.Component);
	;
    break;}
case 478:
#line 2522 "parser.yy"
{ yyval.tree.BlockConfig = start_BlockConfig(yyvsp[0].tree.Name); ;
    break;}
case 479:
#line 2526 "parser.yy"
{
    	    yyval.tree.BlockConfig = yyvsp[-5].tree.BlockConfig;
    	    if(yyval.tree.BlockConfig) {
    	    	check_BlockConfig(yyval.tree.BlockConfig);
    		pop_scope(yyval.tree.BlockConfig);
    	    }
    	;
    break;}
case 480:
#line 2536 "parser.yy"
{ ;
    break;}
case 481:
#line 2537 "parser.yy"
{ ;
    break;}
case 483:
#line 2542 "parser.yy"
{ use(yyvsp[0].tree.SelNameList); ;
    break;}
case 484:
#line 2546 "parser.yy"
{ yyval.tree.BaseConfig = yyvsp[0].tree.BlockConfig; ;
    break;}
case 485:
#line 2547 "parser.yy"
{ yyval.tree.BaseConfig = yyvsp[0].tree.BaseConfig; ;
    break;}
case 486:
#line 2552 "parser.yy"
{ yyval.tree.CompConfig = start_CompConfig(yylsp[-2], yyvsp[-1].tree.ComponentSpec, yyvsp[0].tree.IncrementalBindingIndic); ;
    break;}
case 487:
#line 2555 "parser.yy"
{
    	    nCompConfig cc = yyvsp[-4].tree.CompConfig;
    	    if(cc) {
       	    	cc->config = yyvsp[-3].tree.BlockConfig;
    		pop_scope(cc);
    	    }
    	;
    break;}
case 488:
#line 2565 "parser.yy"
{ yyval.tree.BlockConfig = NULL; ;
    break;}
case 489:
#line 2566 "parser.yy"
{ yyval.tree.BlockConfig = yyvsp[0].tree.BlockConfig; ;
    break;}
case 490:
#line 2570 "parser.yy"
{ yyval.tree.IncrementalBindingIndic = NULL; ;
    break;}
case 491:
#line 2571 "parser.yy"
{ yyval.tree.IncrementalBindingIndic = yyvsp[-1].tree.IncrementalBindingIndic; ;
    break;}
case 492:
#line 2572 "parser.yy"
{ yyval.tree.IncrementalBindingIndic = yyvsp[-1].tree.IncrementalBindingIndic; ;
    break;}
case 493:
#line 2577 "parser.yy"
{
	    nConfigSpec cs = mConfigSpec(yylsp[-3], yyvsp[-2].tree.ComponentSpec, yyvsp[-1].tree.BindingIndic);
	    if(cur_scope->is(nkBlock))
		nBlock(cur_scope)->add_spec(cs);
	;
    break;}
case 494:
#line 2586 "parser.yy"
{
	    yyval.tree.ComponentSpec = mComponentSpec(yyvsp[-2].tree.InstList, yyvsp[0].tree.Component);
	    select_scope(yyvsp[0].tree.Component);
	;
    break;}
case 495:
#line 2594 "parser.yy"
{ yyval.tree.Component = nComponent(find_single_decl(yyvsp[0].tree.Name, nkComponent, "component")); ;
    break;}
case 496:
#line 2598 "parser.yy"
{ yyval.tree.InstList = mInstList_Ids(yylsp[0], yyvsp[0].tree.IdList); ;
    break;}
case 497:
#line 2599 "parser.yy"
{ yyval.tree.InstList = mInstList_ALL(yylsp[0]); ;
    break;}
case 498:
#line 2600 "parser.yy"
{ yyval.tree.InstList = mInstList_OTHERS(yylsp[0]); ;
    break;}
case 499:
#line 2608 "parser.yy"
{ yyval.tree.BindingIndic = build_BindingIndic(yyvsp[0].tree.IncrementalBindingIndic); ;
    break;}
case 500:
#line 2612 "parser.yy"
{ yyval.tree.Scope = selected_scope; unselect_scope(); ;
    break;}
case 501:
#line 2614 "parser.yy"
{ select_scope(yyvsp[-2].tree.Scope); ;
    break;}
case 502:
#line 2616 "parser.yy"
{
	    yyval.tree.IncrementalBindingIndic = mIncrementalBindingIndic(yyvsp[-3].tree.Component, yyvsp[-1].tree.NamedAssocElem, yyvsp[0].tree.NamedAssocElem);
	    unselect_scope();
	;
    break;}
case 503:
#line 2624 "parser.yy"
{
	    yyval.tree.IncrementalBindingIndic = mIncrementalBindingIndic(NULL, yyvsp[-1].tree.NamedAssocElem, yyvsp[0].tree.NamedAssocElem);
	    unselect_scope();
	;
    break;}
case 504:
#line 2629 "parser.yy"
{
    	    yyval.tree.IncrementalBindingIndic = mIncrementalBindingIndic(NULL, NULL, yyvsp[0].tree.NamedAssocElem);
    	    unselect_scope();
    	;
    break;}
case 505:
#line 2637 "parser.yy"
{ yyval.tree.Component = get_architecture(yyvsp[-1].tree.Name, yyvsp[0].id); ;
    break;}
case 506:
#line 2639 "parser.yy"
{ yyval.tree.Component = get_configuration(yyvsp[0].tree.Name); ;
    break;}
case 507:
#line 2641 "parser.yy"
{ yyval.tree.Component = NULL; ;
    break;}
case 508:
#line 2645 "parser.yy"
{ yyval.id = NULL; ;
    break;}
case 509:
#line 2646 "parser.yy"
{ yyval.id = yyvsp[-1].text; ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 487 "bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 2649 "parser.yy"


vaul_error_printer::vaul_error_printer()
{
    log = stderr;
    n_errors = 0;
}

vaul_parser::vaul_parser(vaul_lexer *l)
{
    lex = l;
    lex->set_printer(this, log);
    cur_du = NULL;
    eof = false;
    verbose = false;
}

vaul_parser::~vaul_parser()
{
}

vaul_design_unit *vaul_parser::parse(vaul_libpool *p)
{
    libs = p;
    if(libs->get_worklib() == NULL) {
	set_error(vhdlerr_usage, "no active session");
	return NULL;
    }

    XXX_seen = false;
    init();
    bison_parse();
    if(XXX_seen)
	n_errors++;

    vaul_design_unit *du = finish();
    if(du) {
	lex->pool.store(du->mem);
	du->set_ctime();
    }

    if(n_errors > 0)
	set_error(vhdlerr_errors_detected, "%d errors", n_errors);

    return du;
}

void vaul_parser::clear_errors()
{
    n_errors = 0;
}

