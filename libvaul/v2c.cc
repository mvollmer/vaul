/* VHDL to pseudo C translator    

  Copyright (C) 1994-1996 University of Dortmund
  Department of Electrical Engineering, AG SIV
  All Rights Reserved.

  Permission to use, copy, modify and distribute this software and its
  documentation for non-commercial purposes is hereby granted,
  provided that both the copyright notice and this permission notice
  appear in all copies of the software, derivative works or modified
  versions, and any portions thereof, and that both notices appear in
  supporting documentation.

  THE UNIVERSITY OF DORTMUND ALLOWS FREE USE OF THIS SOFTWARE
  IN ITS "AS IS" CONDITION.  THE UNIVERSITY OF DORTMUND DISCLAIMS
  ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
  FROM THE USE OF THIS SOFTWARE.

  The University of Dortmund requests users of this software
  to return to

       Arbeitsgebiet Schaltungen der Signalverarbeitung
       Fakultät für Elektrotechnik
       Universität Dortmund
       44221 Dortmund, Germany

  or `msipc@nt.e-technik.uni-dortmund.de' any improvements or
  extensions that they make and grant the University of Dortmund
  the unlimited use and distribution of these changes.

  Read README.LICENSING for further information.

*/

#include <vaul/vaul.h>
#include "smart_lib.h"

#include <vaulutil.h>
#include <ctype.h>

void usage()
{
    fprintf(stderr, "usage: %s [-sv -l lib] unit\n", progname);
    exit(1);
}

char *libname = "testlib";
smart_libpool vaul(false);

bool force = false;

extern int optind, opterr;
extern char *optarg;
extern "C" int getopt(int, char *const *, const char *);

bool emit(char *unit, char *lib);

void emit(nDeclaration, int);
void emit(nType);
void emit(nInterface);
void emit(nStatement, int);
void emit(nExpr);
void emit(nConstraint);
void emit(nRange);
void emit(nBlock, int);
void emit(nConcurrentStatement, int);
void emit(nConfigSpec);
void emit(nBindingIndic);

void emit_decls(nScope, int);
void emit_id(nDeclaration);
bool emit_associations(nAssociation assocs, nInterface formals);
void emit_builtin_id(nKind);

bool main_seen = false;

int main(int argc, char *argv[])
{
    int opt;

    util_init(argv);
    opterr = 0;

    while((opt=getopt(argc, argv, "svl:")) != -1) {
	switch(opt) {
	case 's':
	    vaul.flags |= slf_smart;
	    break;
	case 'v':
	    vaul.flags |= slf_verbose;
	    break;
	case 'f':
	    force = true;
	    break;
	case 'l':
	    libname = optarg;
	    break;
	case '?':
	    usage();
	    break;
	}
    }

    if(optind >= argc || argc-1 > optind)
	usage();

    char *unit = argv[optind];

    bool success = emit(libname, unit);

    if(success && main_seen && false) {
	printf("\nint main(int argc, char **argv)\n{\n");
	printf("  printf(\"-> %%d\\n\", v_main(atoi(argv[argc-1])));\n");
	printf("}\n");
    }

    return success? 0 : 1;
}

vaul_design_unit *cur_du;

bool emit(char *lib, char *unit)
{
    if(vaul_design_unit *du = vaul.get(lib, unit)) {
	if(du->is_error()) {
	    du->print_err(unit);
	    du->release();
	    return false;
	}
	cur_du = du;
	printf("/* generated by v2c from %s.%s\n*/\n\n", lib, unit);
	for(vaul_design_unit *used = du->query_used_dus(NULL); used;
	    used = du->query_used_dus(used)) {
	    printf("#include %s/%s\n", used->lib->get_name(),
		   used->get_name());
	}
	if(du->query_used_dus(NULL))
	    printf("\n");
	emit(du->tree, 0);
	du->release();
    } else {
	if(vaul.is_error())
	    vaul.print_err();
	else
	    fprintf(stderr, "%s not found in %s\n", unit, lib);
	return false;
    }

    return true;
}

char *spaces(int l)
{
    if(l > 30)
	l = 30;
    return "                              " + (30-l);
}

void emit_id(const char *id)
{
    if(*id == '\\' || *id == '\'')
	printf("%s", id);
    else {
	bool break_on_caps = false;
	while(*id) {
	    if(isupper(*id) && break_on_caps)
		putchar('_');
	    break_on_caps = islower(*id);
	    putchar(tolower(*id++));
	}
    }
}

void emit_id(nDeclaration d)
{
    if(d->id) {
	if(d->is(nkEnumLiteral)) {
#if 0
	    emit_id(nEnumLiteral(d)->type);
	    printf("_");
	    if(d->id[0] == '\'') {
		if(isalnum(d->id[1]))
		    printf("%c", d->id[1]);
		else
		    printf("%2x", unsigned(d->id[1]));
	    } else
#endif
		emit_id(d->id);
	} else {
	    emit_id(d->id);
#if 0
	    if(d->is(nkSubprogram) && strcmp(d->id, "main")) {
		for(nInterface i = nSubprogram(d)->first_formal; i;
		    i = i->next_element)
		    emit_id(i->type);
		if(d->is(nkFunction)) {
		    printf("_");
		    emit_id(nFunction(d)->return_type);
		}
	    }
#endif
	}
	if(!strcmp(d->id, "main"))
	    main_seen = true;
    } else
	printf("<anonymous>");
}

void emit_decls(nScope s, int l)
{
    for(nDeclaration d = s->first_decl; d; d = d->next_decl)
	emit(d, l);
}

void emit_def(nType t)
{
    while(t->is(nkSubType)) {
	nType b = nSubType(t)->base;
	if(b->id) {
	    emit_id(b);
	    return;
	}
	t = b;
    }

    if(t->is(nkIntegerType) || t->is(nkPhysicalType))
	printf("int");
    else if(t->is(nkFloatingType))
	printf("double");
    else if(t->is(nkEnumType)) {
	printf("enum { ");
	for(nEnumLiteral el = nEnumType(t)->first; el; el = el->next) {
	    emit_id(el);
	 /* if(el->id[0] == '\'')
		printf(" = %s", el->id); */
	    if(el->next)
		printf(", ");
	}
	printf(" }");
    } else if(t->is(nkArrayType)) {
	if(vaul_name_eq(nArrayType(t)->element_type->id, "character")
	   && t->scope->is(nkStandardPackage))
	    printf("char");
	else
	    emit(nArrayType(t)->element_type);
	for(nIndexType it = nArrayType(t)->first_index; it; it = it->next) {
	    printf("[");
	    emit(it->index_type);
	    printf("]");
	}
    } else if(t->is(nkRecordType)) {
	printf("struct {\n");
	for(nRecordElement re = nRecordType(t)->first_element;
	    re; re = re->next) {
	    printf("  ");
	    emit(re->type);
	    printf(" ");
	    emit_id(re->id);
	    printf(";\n");
	}
	printf("}");
    } else if(t->is(nkAccessType)) {
	emit(nAccessType(t)->designated);
	printf("*");
    } else if(t->is(nkFileType)) {
	printf("file<");
	emit(nFileType(t)->content_type);
	printf(">");
    } else
	printf("/* %s */", t->type_id());
}

void emit(nDeclaration d, int l)
{
    if(d->is(nkSubprogram)
       && !(d->next_decl && d->next_decl->is(nkSubprogramBody))) {
	nSubprogram s = nSubprogram(d);
	if(s->is(nkFunction))
	    emit(nFunction(s)->return_type);
	else
	    printf("void");
	printf(" ");
	emit_id(s);
	printf(" (");
	for(nInterface i = s->first_formal; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element)
		printf(", ");
	}
	printf(");\n");
    } else if(d->is(nkSubprogramBody)) {
	nSubprogram s = nSubprogram(nScope(d)->continued);
	printf("\n");
	if(s->is(nkFunction))
	    emit(nFunction(s)->return_type);
	else
	    printf("void");
	printf(" ");
	emit_id(s);
	printf(" (");
	for(nInterface i = s->first_formal; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element)
		printf(", ");
	}
	printf(")\n{\n");
	emit_decls(nSubprogramBody(d), 2);
	if(nScope(d)->first_decl)
	    printf("\n");
	emit(nSubprogramBody(d)->stats, 2);
	printf("}\n");
    } else if(d->is(nkVariable)
      || (d->is(nkConstant) && nConstant(d)->initial_value != NULL)) {
	printf("%s", spaces(l));
	emit(nObject(d)->type);
	printf(" ");
	emit_id(d);
	if(nObject(d)->initial_value) {
	    printf(" = ");
	    emit(nObject(d)->initial_value);
	}
	printf(";\n");
    } else if(d->is(nkConstant) && nConstant(d)->initial_value == NULL) {
	printf("%sextern ", spaces(l));
	nConstant c = nConstant(d);
	emit(c->type);
	printf(" ");
	emit_id(c);
	printf(";\n");
    } else if(d->is(nkConstantBody)) {
	printf("%s", spaces(l));
	nConstant c = nConstantBody(d)->decl;
	emit(c->type);
	printf(" ");
	emit_id(c);
	printf(" = ");
	emit(nConstantBody(d)->initial_value);
	printf(";\n");
    } else if(d->is(nkFile)) {
	nFile f = nFile(d);
	printf("%s", spaces(l));
	emit(f->type);
	printf(" ");
	emit_id(f);
	if(f->initial_value) {
	    printf(" = open (");
	    emit(f->initial_value);
	    if(f->open_mode) {
		printf(", ");
		emit(f->open_mode);
	    }
	    printf(")");
	}
	printf(";\n");
    } else if(d->is(nkSignal)) {
	nSignal s = nSignal(d);
	printf("%ssig<", spaces(l));
	emit(s->type);
	printf("> ");
	emit_id(s);
	if(s->initial_value) {
	    printf(" = ");
	    emit(s->initial_value);
	}
	printf(";\n");
    } else if(d->is(nkType)) {
	if(d->id) {
	    printf("%s", spaces(l));
	    printf("typedef ");
	    emit_def(nType(d));
	    printf(" ");
	    emit_id(d);
	    printf(";\n");
	}
    } else if(d->is(nkPackage) || d->is(nkPackageBody)) {
	printf("\n/* %s %s\n*/\n\n", d->type_id(), d->id);
	emit_decls(nScope(d), 0);
    } else if(d->is(nkEntity)) {
	nEntity e = nEntity(d);
	printf("entity ");
	emit_id(d);
	printf(" (");
	for(nInterface i = e->first_generic; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element || e->first_port)
		printf(", ");
	}
	for(nInterface i = e->first_port; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element)
		printf(", ");
	}
	printf(")\n");
	emit(e, 0);
    } else if(d->is(nkArchitecture)) {
	nArchitecture a = nArchitecture(d);
	nEntity e = nEntity(a->continued);
	printf("architecture<");
	emit_id(e);
	printf("> ");
	emit_id(a);
	printf("\n");
    	emit(a, 0);
    } else if(d->is(nkConfiguration)) {
	printf("\n/* configuration %s\n*/\n\n", d->id);
    } else if(d->is(nkComponent)) {
	nComponent c = nComponent(d);
	printf("%scomponent ", spaces(l));
	emit_id(c);
	printf(" (");
	for(nInterface i = c->first_generic; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element || c->first_port)
		printf(", ");
	}
	for(nInterface i = c->first_port; i; i = i->next_element) {
	    emit(i);
	    if(i->next_element)
		printf(", ");
	}
	printf(");\n");
    } else if(false)
	printf("%s/* %s %s */\n", spaces(l), d->type_id(), d->id);
}

void emit(nType t)
{
    if(t->id)
	emit_id(t);
    else if(t->is(nkSubType)) {
	emit(nSubType(t)->base);
	printf(" ");
	emit(nSubType(t)->constraint);
    } else
	emit_def(t);
}

void emit(nConstraint c)
{
    if(c->is(nkRange))
	emit(nRange(c));
    else if(c->is(nkIndexConstraint)) {
	printf("[");
	emit(nIndexConstraint(c)->type);
	printf("]");
	emit(nIndexConstraint(c)->next);
    }
}

void emit(nInterface i)
{
    if(i->object_class == ObjClass_Signal) {
	printf("sig<");
	emit(i->type);
	printf(">");
    } else
	emit(i->type);
    if(i->object_class == ObjClass_Variable)
	printf("&");
    if(i->id) {
	printf(" ");
	emit_id(i);
    }
#if 1
    if(i->initial_value) {
	printf(" = ");
	emit(i->initial_value);
    }
#endif
}

void emit(nStatement s, int l)
{
    if(s == NULL)
	return;

    if(s->label)
	printf("%s:\n", s->label->id);

    printf("%s", spaces(l));
    if(s->is(nkNullStat))
	printf(";\n");
    else if(s->is(nkReturnStat)) {
	if(nReturnStat(s)->value) {
	    printf("return ");
	    emit(nReturnStat(s)->value);
	    printf(";\n");
	} else
	    printf("return;\n");
    } else if(s->is(nkVarAssignment)) {
	emit(nVarAssignment(s)->target);
	printf(" = ");
	emit(nVarAssignment(s)->value);
	printf(";\n");
    } else if(s->is(nkIfStat)) {
	nIfStat is = nIfStat(s);
	printf("if(");
	emit(is->cond);
	printf(") {\n");
	emit(is->then_stats, l+2);
	if(is->else_stats) {
	    printf("%s} else {\n", spaces(l));
	    emit(is->else_stats, l+2);
	}
	printf("%s}\n", spaces(l));
    } else if(s->is(nkCaseStat)) {
	nCaseStat cs = nCaseStat(s);
	printf("switch(");
	emit(cs->switch_expr);
	printf(") {\n");
	for(nCaseAlternative ca = cs->first_alternative; ca; ca = ca->next) {
	    for(nChoice c = ca->first_choice; c; c = c->next) {
		if(c->is(nkOthersChoice))
		    printf("%sdefault:\n", spaces(l));
		else {
		    printf("%scase ", spaces(l));
		    if(c->is(nkExprChoice))
			emit(nExprChoice(c)->expr);
		    else if(c->is(nkRangeChoice)) {
			nGenAssocElem ae = nRangeChoice(c)->range;
			if(ae->is(nkRangeAssocElem))
			    emit(nRangeAssocElem(ae)->range);
			else if(ae->is(nkSubtypeAssocElem))
			    emit(nSubtypeAssocElem(ae)->type);
		    } else
			printf("%s", c->type_id());
		    printf(":\n");
		}
	    }
	    emit(ca->stats, l+2);
	    printf("%sbreak;\n", spaces(l+2));
	}
	printf("%s}\n", spaces(l));
    } else if(s->is(nkLoopStat)) {
	nLoopStat ls = nLoopStat(s);
	if(ls->iteration_scheme == NULL) {
	    printf("while(1)");
	} else if(ls->iteration_scheme->is(nkWhileScheme)) {
	    printf("while(");
	    emit(nWhileScheme(ls->iteration_scheme)->condition);
	    printf(")");
	} else if(ls->iteration_scheme->is(nkForScheme)) {
	    nForScheme fs = nForScheme(ls->iteration_scheme);
	    printf("for(");
	    emit(fs->var->type);
	    printf(" ");
	    emit_id(fs->var);
	    printf(" = ");
	    emit(fs->range);
	    printf(")");
	} else
	    printf("/* %s */", ls->iteration_scheme->type_id());
	printf(" {\n");
	emit(ls->stats, l+2);
	printf("%s}\n", spaces(l));
    } else if(s->is(nkProcedureCallStat)) {
	nProcedure p = nProcedureCallStat(s)->proc;
	emit_id(p);
	printf(" (");
	emit_associations(nProcedureCallStat(s)->first_actual,
			  p->first_formal);
	printf(");\n");
    } else if(s->is(nkWaitStat)) {
	nWaitStat ws = nWaitStat(s);
	printf("wait");
	if(ws->first_sensitivity) {
	    printf(" on ");
	    for(nSignalList sn = ws->first_sensitivity; sn; sn = sn->next) {
		emit(sn->signal);
		if(sn->next)
		    printf(", ");
	    }
	}
	if(ws->condition) {
	    printf(" until ");
	    emit(ws->condition);
	}
	if(ws->timeout) {
	    printf(" for ");
	    emit(ws->timeout);
	}
	printf(";\n");
    } else if(s->is(nkAssertStat)) {
	nAssertStat as = nAssertStat(s);
	printf("assert(");
	emit(as->condition);
	printf("); /* ");
	emit(as->severity);
	printf(" ");
	emit(as->report);
	printf(" */\n");
    } else if(s->is(nkLoopControlStat)) {
	nLoopStat l = nLoopControlStat(s)->loop;
	if(nLoopControlStat(s)->when) {
	    printf("if(");
	    emit(nLoopControlStat(s)->when);
	    printf(") ");
	}
	char *stat = s->is(nkExitStat)? "break" : "continue";
	if(l && l->label)
	    printf("goto %s_%s;\n", l->label->id, stat);
	else
	    printf("break;\n");
    } else if(s->is(nkSignalAssignment)) {
	nSignalAssignment sa = nSignalAssignment(s);
	emit(sa->target);
	printf(" <~ ");
	for(nWaveformElement we = sa->first_wave; we; we = we->next) {
	    emit(we->value);
	    if(we->after) {
		printf(" @ ");
		emit(we->after);
	    }
	    if(we->next)
		printf(", ");
	}
	printf(";\n");
    } else
	printf("/* XXX %s */\n", s->type_id());
    if(s->next)
	emit(s->next, l);
}

bool is_op(char *id)
{
    return id[0] == '"';
}

char *map_bin_op(char *id)
{
    if(is_op(id)) {
	char *op = xstrdup(id+1);
	op[strlen(op)-1] = '\0';
	if(!strcmp(op, "="))
	    op = "==";
	else if(!strcmp(op, ":="))
	    op = "=";
	else if(!strcmp(op, "/="))
	    op = "!=";
	else if(!strcmp(op, "mod"))
	    op = "%";
	else if(!strcmp(op, "or"))
	    op = "||";
	else if(!strcmp(op, "and"))
	    op = "&&";
	else if(!strcmp(op, "&"))
	    op = " concat ";
	return op;
    } else
	return NULL;
}

char *map_un_op(char *id)
{
    if(is_op(id)) {
	char *op = xstrdup(id+1);
	op[strlen(op)-1] = '\0';
	if(!strcmp("not", op))
	    op = "!";
	return op;
    } else
	return NULL;
}

void emit(nPhysicalUnit u)
{
    if(u->value == NULL)
	printf("1");
    else {
	printf("%s*", u->value->value);
	emit(u->value->unit);
    }
}

void emit(nExpr e)
{
    if(e == NULL)
	printf("/* NULL expr */");
    else if(e->is(nkFunctionCall)) {
	nFunctionCall fc = nFunctionCall(e);
	int n_args = 0;
	for(nAssociation a = fc->first_actual; a; a = a->next)
	    n_args++;
	char *c_op;
	char *fid = fc->func->idstr();
	if(n_args == 2 && (c_op = map_bin_op(fid))) {
	    printf("(");
	    emit(fc->first_actual->actual);
	    printf("%s", c_op);
	    emit(fc->first_actual->next->actual);
	    printf(")");
	} else if(n_args == 1 && (c_op = map_un_op(fid))) {
	    printf("(");
	    printf("%s", c_op);
	    emit(fc->first_actual->actual);
	    printf(")");
	} else if(!is_op(fid)) {
	    emit_id(fc->func);
	    printf(" (");
	    emit_associations(fc->first_actual, fc->func->first_formal);
	    printf(")");
	} else
	    printf("(%s, %d args)", fid, n_args);
    } else if(e->is(nkSimpleObjectRef)) {
	emit_id(nSimpleObjectRef(e)->object);
    } else if(e->is(nkLiteralRef)) {
	if(e->is(nkPhysicalLiteralRef))
	    printf("(");
	printf("%s", nLiteralRef(e)->value? :"1");
	if(e->is(nkPhysicalLiteralRef)) {
	    printf("*");
	    emit(nPhysicalLiteralRef(e)->unit);
	    printf(")");
	}
    } else if(e->is(nkTypeConversion)) {
	printf("((");
	emit(nTypeConversion(e)->target_type);
	printf(")(");
	emit(nTypeConversion(e)->expression);
	printf("))");
    } else if(e->is(nkQualifiedExpr)) {
	emit(nQualifiedExpr(e)->expression);
    } else if(e->is(nkEnumLitRef)) {
	emit_id(nEnumLitRef(e)->value);
    } else if(e->is(nkArrayObjectRef)) {
	nArrayObjectRef aor = nArrayObjectRef(e);
	emit(aor->array);
	for(nIndexValue iv = aor->first_index; iv; iv = iv->next) {
	    printf("[");
	    emit(iv->index);
	    printf("]");
	}
    } else if(e->is(nkArrayLiteralRef)) {
	printf("(");
	emit(nArrayLiteralRef(e)->type);
	printf(") %s", nArrayLiteralRef(e)->value);
    } else if(e->is(nkRecordObjectRef)) {
	emit(nRecordObjectRef(e)->record);
	printf(".");
	emit_id(nRecordObjectRef(e)->element->id);
    } else if(e->is(nkRecordAggregate)) {
	nRecordAggregate ra = nRecordAggregate(e);
	printf("{ ");
	for(nRecAggrAssoc raa = ra->first_assoc; raa; raa = raa->next) {
	    printf("%s: ", raa->elem->id);
	    emit(raa->actual);
	    if(raa->next)
		printf(", ");
	}
	printf(" }");
    } else if(e->is(nkArrayAggregate)) {
	nArrayAggregate aa = nArrayAggregate(e);
	printf("{ ");
	for(nArrAggrAssoc aaa = aa->first_assoc; aaa; aaa = aaa->next) {
	    if(aaa->is(nkSingleArrAggrAssoc)) {
		if(nExpr idx = nSingleArrAggrAssoc(aaa)->index) {
		    printf("[");
		    emit(idx);
		    printf("] = ");
		}
	    } else if(aaa->is(nkRangeArrAggrAssoc)) {
		printf("[");
		emit(nRangeArrAggrAssoc(aaa)->range);
		printf("] %s ", aaa->is(nkSliceArrAggrAssoc)? "=" : "fill");
	    } else if(aaa->is(nkOthersArrAggrAssoc))
		printf("[others] = ");
	    else
		printf("%s =", aaa->type_id());
	    emit(aaa->actual);
	    if(aaa->next)
		printf(", ");
	}
	printf(" }");
    } else if(e->is(nkSliceObjectRef)) {
	nSliceObjectRef sr = nSliceObjectRef(e);
	emit(sr->array);
	printf("[");
	if(sr->slice->is(nkSubType)) {
	    nSubType st = nSubType(sr->slice);
	    if(st->constraint->is(nkRange))
		emit(nRange(st->constraint));
	    else
		printf("/* invalid slice */");
	} else
	    emit(sr->slice);
	printf("]");
    } else if(e->is(nkAccessObjectRef)) {
	printf("*");
	emit(nAccessObjectRef(e)->access);
    } else if(e->is(nkAttrSignalRef)) {
	emit_builtin_id(e->kind());
	printf("(");
	emit(nAttrSignalRef(e)->signal);
	printf(")");
    } else if(e->is(nkAttrSigFunc)) {
	emit_builtin_id(e->kind());
	printf("(");
	emit(nAttrSigFunc(e)->signal);
	printf(")");
    } else if(e->is(nkAttrTypeFunc)) {
	emit_builtin_id(e->kind());
	printf("(");
	emit(nAttrTypeFunc(e)->prefix);
	if(nAttrTypeFunc(e)->argument) {
	    printf(", ");
	    emit(nAttrTypeFunc(e)->argument);
	}
	printf(")");
    } else if(e->is(nkArrayAttr)) {
	emit_builtin_id(e->kind());
	printf("(");
	emit_id(nArrayAttr(e)->array);
	printf(", %d)", nArrayAttr(e)->index);
    } else
	printf("/* XXX %s */", e->type_id());
}

void emit(nRange r)
{
    if(r->is(nkExplicitRange)) {
	nExplicitRange er = nExplicitRange(r);
	emit(er->first);
	printf(" %s ", er->dir == DirectionUp? "to" : "downto");
	emit(er->last);
    } else if(r->is(nkArrayRange)) {
	printf("%s(", r->is(nkArrayAttr_RANGE)? "range" : "reverse_range");
	emit_id(nArrayRange(r)->array);
	printf(", %d)", nArrayRange(r)->index);
    } else
	printf("/* %s */", r->type_id());
}

bool emit_associations(nAssociation assocs, nInterface formals)
{
    bool need_comma = false;
    for(nInterface f = formals; f; f = f->next_element) {
	nAssociation a;
	for(a = assocs; a; a = a->next)
	    if(a->formal == f)
		break;
	if(a) {
	    if(a->formal_conversion) {
		printf("/* converted by ");
		emit_id(a->formal_conversion);
		printf(" */");
	    }
	    emit(a->actual);
	} else if(f->initial_value)
	    emit(f->initial_value);
	else
	    printf("XXX");

	need_comma = true;
	if(f->next_element)
	    printf(", ");
    }
    return need_comma;
}

void emit_builtin_id(nKind k)
{
    printf("%s", sNode::type_id(k));
}

void emit(nBlock b, int l)
{
    printf("%s{\n", spaces(l));
    emit_decls(b, l+2);
    if(b->first_decl && b->stats)
	printf("\n");
    emit(b->stats, l+2);
    printf("%s}\n", spaces(l));
}

void emit(nConcurrentStatement s, int l)
{
    if(s == NULL)
	return;

    printf("%s", spaces(l));
    if(s->is(nkProcess)) {
	nProcess p = nProcess(s);
	printf("process ");
	emit_id(p);
	printf(" (");
	for(nSignalList sl = p->sensitivities; sl; sl = sl->next) {
	    emit(sl->signal);
	    if(sl->next)
		printf(", ");
	}
	printf(")\n%s{\n", spaces(l));
	emit_decls(p, l+2);
	if(p->first_decl)
	    printf("\n");
	emit(p->stats, l+2);
	printf("%s}\n", spaces(l));
	if(s->next_stat)
	    printf("\n");
    } else if(s->is(nkComponentInst)) {
	nComponentInst ci = nComponentInst(s);
	emit(ci->binding);
	if(ci->config) {
	    printf(": ");
	    emit(ci->config);
	}
	printf(";\n");
    } else if(s->is(nkBlockStat)) {
	nBlockStat bs = nBlockStat(s);
	printf("block ");
	emit(bs->binding);
	printf("\n");
	emit(nBlock(bs), l);
	printf("\n");
    } else
	printf("/* %s */\n", s->type_id());
    emit(s->next_stat, l);
}

void emit(nConfigSpec s)
{
    emit(s->binding);
}

void emit(nBindingIndic b)
{
    emit_id(b->unit);
    printf(" (");
    bool nc = emit_associations(b->generic_assoc, b->unit->first_generic);
    if(nc && b->port_assoc)
	printf(", ");
    emit_associations(b->port_assoc, b->unit->first_port);
    printf(")");
}
